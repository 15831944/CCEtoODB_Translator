/* Copyright Mentor Graphics Corporation 2004

    All Rights Reserved.

 THIS WORK CONTAINS TRADE SECRET
 AND PROPRIETARY INFORMATION WHICH IS THE
 PROPERTY OF MENTOR GRAPHICS
 CORPORATION OR ITS LICENSORS AND IS
 SUBJECT TO LICENSE TERMS. 
*/

// Name:				ST_Graphics.h
// Date:				03.01.05
// Description:	APP<-->DLL graphics interface

#ifndef _UPG_GRAPHICS_H_
#define _UPG_GRAPHICS_H_

//#define UPD_08_30_05 1
#define ORIGIN_DEBUG 0

#ifndef SGN_TYPE_OBJ_MAX //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ there is a copy in GL_GeomIter.h
// nodes generated by application
#define SGN_TYPE_UNKNOWN	0
#define TYPE_PLANE_SHAPE	1
#define TYPE_OBSTACLE		2
#define TYPE_ROUTE_BORDER	3
#define TYPE_PES_OBJECT		4
#define TYPE_PLANE_APS 12
// nodes visible for application
#define SGN_TYPE_SUB_SHAPE	5
#define	SGN_TYPE_THERMAL	6
#define	SGN_TYPE_TIELEG		7
#define	SGN_TYPE_LIN_SEC	8
#define	SGN_TYPE_GEOM_LST	9
#define SGN_TYPE_PES_CUT	10

// nodes where use is defined by the application 
#define SGN_TYPE_APPL1		13 
#define	SGN_TYPE_OBJ_MAX	(SGN_TYPE_APPL1 + 1)

/////////////// GetHatchingParams modes //////////////////
// plane status
const unsigned int IS_PLANE_VISIBLE				= 0x00000001;
const unsigned int IS_PLAIN_VISIBLE				= 0x00000001; // obsolete
const unsigned int DISCARD_UNTIED_AREAS			= 0x00000002; // don't draw if not connected to metal ...
const unsigned int DISCARD_UNITED_AREAS			= 0x00000002; // obsolete
// Filling modes
const unsigned int HATCH_PATTERN				= 0x00000010; //  use Pattern filling
const unsigned int HATCH_NEGATIVE				= 0x00000020; // only for HATCH_PATTERN: fill outside of the pattern
const unsigned int HATCH_BOUND					= 0x00000040; // only for HATCH_PATTERN: fill Bound cells
const unsigned int HATCH_CROSS					= 0x00000080; // do cross hatch at the orthogonal angle
const unsigned int PARTIAL_HATCH_AREAS			= 0x00000100; // only for HATCH_CROSS: ...
const unsigned int RESTRICT_BOUNDARY_TO_PATTERN = 0x00000200; // only for orthogonal patterns
const unsigned int SNAP_TO_HATCH_GRID			= 0x00000400; // only for RESTRICT_BOUNDARY_TO_PATTERN:
// The SNAP_TO_HATCH_GRID value is relevent only the RESTRICT_BOUNDARY_TO_PATTERN 
// This will snap all clearance and hatch lines to the hatch grid. 
// The hatch grid is defined by the board origin and the hatch distance.
const unsigned int DRAW_SELECTED	= 0x00000800;
const unsigned int DRAW_STIPPLED	= 0x00001000;    
const unsigned int DRAW_HIGHLIGHTED = 0x00002000;    
const unsigned int DRAW_DOTTED		= 0x00004000;    
const unsigned int DRAW_PRIEVIEW	= 0x00008000;    // for PES cuts
const unsigned int LPSM_TIE_BRIDGING= 0x00010000;    // Bridging mode
const unsigned int HATCH_PATTERN2	= 0x00020000; // special filling for gerber

#endif	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~SGN_TYPE_OBJ_MAX

class DrwFill;

class SYSGL_API cPlaneShapeOutlineDraw
{
private:
    // all coordinates are database coordinates.  Input and output.
    int x1,x2,y1,y2;   // Drawing box.
    int layer;         // Drawing layer.  

public:
    int is_arc;
	DrwFill *df;

public:
    cPlaneShapeOutlineDraw();
    cPlaneShapeOutlineDraw( int x1, int y1, int x2, int y2, int layer);
    void Initialize (int xmin, int ymin, int xmax, int ymax, int layer);
    void Draw();        // Function that draws all outlines in the box.

#ifdef UPD_08_30_05
    virtual int ChangeStyle (int width, int net_number, bool bPlaneEnabled) = 0;
#else
    virtual void ChangeStyle (int width, int net_number) = 0;
#endif
    //
    // called by UPG before any drawing starts, and whenever UPG 
    // determines a style-change needs to be performed by the 
    // graphics system.
    //
    // width      – width in database units of lines/arcs to follow
    // net_number – some number to uniquely identify each net.  The graphics
    //              system will translate this number into a color change if
    //              required.

    virtual void DrawSegments (int num_lines, const int *points) = 0;
    //
    // num_lines – count of number of lines in the array
    // points    - contains an array of integer pairs (x0, y0, x1, y1, …) all in
    //             database coordinates.
    //
    // Notes:
    //  UPG is responsible for memory contained in points.  The graphics
    //  system is not allowed to modify the data.


    virtual void DrawArcs (int num_arcs, const int *arc_data) = 0;
    //
    // num_arcs - count of number of arcs in the array
    // arc_data - pointer to an array of integers.  Exact format to be defined,
    //             all in database coordinates.
    //
    // Notes:
    //  UPG is responsible for memory contained in arc_data.  The
    //  graphics system is not allowed to modify the data.

    virtual void DrawCircles (int num_circles, const int *circle_data) = 0;
    //
    // num_circles - count of number of circles in the array
    // circle_data - pointer to an array of integers.  Exact format to be defined,
    //             all in database coordinates.
    //
    // Notes:
    //  UPG is responsible for memory contained in arc_data.  The
    //  graphics system is not allowed to modify the data.

	virtual void DrawPolylines (int num, const int *plines);
    //
    // num - count of number of polylines in the array
    // plines - pointer to an array of integers. All in database coordinates.
	// plines = {num_pnt1, num_pnt2, ..., num_pntN, {points_for_poly1}, {points_for_poly2}, ..., {points_for_polyN}}
	// ==> plines[0] = num_pnt1, ..., plines[num-1] = num_pntN, plines[num] = x01, ...
    //
    // Notes:
    //  UPG is responsible for memory contained in polyline_data.
    //  The graphics system allowed to modify the data.

	void GetBox(long &lx, long &ly, long &ux, long &uy) {lx = x1; ly = y1; ux = x2; uy = y2;}
	int GetLayer() { return layer;}
	void SetOutputTypes(int *types = NULL, int count = 0);
	// only given objects types will be sent to the graphics system
	// the order of output correspond to the order in the input array
	// count = 0 - means "all type" and the output order is {SGN_TYPE_SUB_SHAPE, SGN_TYPE_TIELEG}
	// two objects types are supported now (11/15/05)
	
	int	GetCurrentType(); 	// returns the type of output objects
};


class SYSGL_API cPlaneShapeFillDraw
{
private:
//public:
    int x1,x2,y1,y2;    // Drawing box (database coords)
    int layer;          // Drawing layer
    int gridX0, gridY0; // Pixel grid origin (screen coord)
    int stepX, stepY;   // Pixel grid steps (screen coord)
	int is_dbu_coord;
public:
	DrwFill *df;		// parameters of the current sub shape

public:
	cPlaneShapeFillDraw();
    cPlaneShapeFillDraw ( int x1, int y1, int x2, int y2, int layer);

    // deferred constructor
    void Initialize (int xmin, int ymin, int xmax, int ymax, int layer,
                     int gridX0, int gridY0, int stepX, int stepY);

    void SetHatchMode (int is_dbu_coord, int x0, int y0, int dx, double cs, double sn);

    void Draw();        // Function that fills shape in the box.


#ifdef UPD_08_30_05
    virtual int ChangeStyle (int net_number, bool bPlaneEnabled) = 0;
#else
    virtual void ChangeStyle (int net_number) = 0; 
#endif
	int GetLineWidth();
    //
    // called by UPG before any drawing starts, and whenever UPG 
    // determines a style-change needs to be performed by the 
    // graphics system.
    //
    // net_number – some number to uniquely identify each net.  The graphics
    //              system will translate this number into a color change if
    //              required.  How this net # gets to UPG is to be defined.

    virtual void DrawSegments (int num_lines, const short *points, bool bVertical) = 0;
    //
    // num_lines – count of number of lines in the array (i.e. #points = 2 * num_lines)
    // points    - contains an array of shorts.  Exact format to be defined. all in
    //             screen coordinates.  Assumed to be 
    //             (x1start, y1start, x1end, y1end), (x2start, y2start, x2end, y2end), etc.
    // bVertical - All segments are assumed to be horizontal, or all vertical.  If
    //             bVertical is true, then all are vertical.  For now (until we get
    //             rotated views, I will assume bVertical is always false.
    //
    // Notes:
    //  1)  UPG is responsible for memory contained in points.  The graphics
    //      system is not allowed to modify the data.
    //      
    virtual void DrawSegmentsDBU (int num_lines, const long *points) = 0;
    //
    // num_lines – count of number of lines in the array (i.e. #points = 2 * num_lines)
    // points    - contains an array of LONGs. all in DBU (Data Base Units)
	 // points = { x1, y1, x2, y2, ...xN, yN}, where N = num_lines
    //
    // Notes:
    //  1)  UPG is responsible for memory contained in points.  The graphics
    //      system is not allowed to modify the data.
    //  2)	the direction of hatching line is determined by vector {csn, sns}    

	void GetBox(long &lx, long &ly, long &ux, long &uy) {lx = x1; ly = y1; ux = x2; uy = y2;}
	void GetGrid(long &x, long &y, long &dx, long &dy) {x = gridX0; y = gridX0; dx = stepX; dy = stepY;}
	int GetLayer() {return layer;}
	int IsDBU()		{return is_dbu_coord;}
	void SetOutputTypes(int *types = NULL, int count = 0);
	// only given objects types will be sent to the graphics system
	// the order of output correspond to the order in the input array
	// count = 0 - means "all type" and the output order is {SGN_TYPE_SUB_SHAPE, SGN_TYPE_TIELEG}
	// two objects types are supported now (11/15/05)

	int	GetCurrentType(); 	// returns the type of output objects
};


//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Class for description of fillings ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


class VectPattern;
class GeomIter;
class GeomHdr;
class SGN_Controller;

class SYSGL_API DrwFill
{
public:
	long gx, gy;	// grid origin
	long dx, dy;	// dx,dy - steps of grid
	long wx, wy;	// hatch line width: wx - horizontal line width, wy - vertical line width
	double cs, sn;	// direction cs = cos(fi); sn = sin(fi)
	long pixel_size;
	unsigned int hm;	// modes: HATCH_PATTERN | HATCH_CROSS | HATCH_NEGATIVE | HATCH_BOUND
	VectPattern *vp;	// pattern
	long bx1, bx2, by1, by2;	// clip box is used by hatch if it is valid (bx1 < bx2 && by1 < by2)
	int TypesOrd[SGN_TYPE_OBJ_MAX];
	int num_types;
	int crn_type;
	int net_id;
	int subnet_id;
	SGN_Controller *geom_cont;
public:
	DrwFill();
	~DrwFill();

	void			GetOrigin(long &x, long &y);
	long			GetDx();
	long			GetDy();
	long			GetWidth();
	long			GetOrthoWidth();
	long			GetPixelSize();
	void			GetDirection(double &x, double &y);
	SGN_Controller *GetGeomCont() {return geom_cont;}
	int				IsCrossHatch();
	int				IsPatternHatch();
	int				IsNegativeHatch();
	int				IsBoundHatch();
	int				IsPlaneDisabled();
	VectPattern*	GetPattern();
	void			GetClipBox(long &lx, long &ly, long &ux, long &uy);
	int				GetCurrentType();

	void			SetOrigin(long x, long y);
	void			SetDx(long d_x);
	void			SetDy(long d_y);
	void			SetWidth(long w_x);
	void			SetOrthoWidth(long w_y);
	void			SetPixelSize(long size);
	void			SetDirection(double x, double y);
	void			SetCrossHatch(int set_val);
	void			SetPatternHatch(int set_val);
	void			SetNegativeHatch(int set_val);
	void			SetBoundHatch(int set_val);
	void			SetPlaneDisabled(int set_val);
	void			SetPattern(GeomHdr *patt_poly_list);
	void			SetClipBox(long lx, long ly, long ux, long uy);
	unsigned int	SetHatchingParams(GeomIter *itr);
	void			SetOutputTypes(int *types, int count);
	void			SetGeomCont(SGN_Controller *cnt) {geom_cont = cnt;}

	void			CreateDrwFill(char *ini_file, char *patt_poly_file);
};

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#endif //  _UPG_GRAPHICS_H_

