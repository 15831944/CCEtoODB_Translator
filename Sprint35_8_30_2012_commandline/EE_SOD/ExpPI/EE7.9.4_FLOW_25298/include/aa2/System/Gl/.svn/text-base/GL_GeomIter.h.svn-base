/* Copyright Mentor Graphics Corporation 2004

    All Rights Reserved.

 THIS WORK CONTAINS TRADE SECRET
 AND PROPRIETARY INFORMATION WHICH IS THE
 PROPERTY OF MENTOR GRAPHICS
 CORPORATION OR ITS LICENSORS AND IS
 SUBJECT TO LICENSE TERMS. 
*/
// test comment
// test comment 2 part of checkin at ALH replica.
// Name:				GL_GeomIter.h
// Date:				12.20.04
// Author:			Alexander Zabolotnikov	
// Description:	APP<-->DLL interface

#ifndef _GEOM_ITER_H_
#define _GEOM_ITER_H_

class GeomIter;
class GL_Node;
class SGN_Controller;
class DrwFill;

#ifndef SGN_TYPE_OBJ_MAX //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ there is a copy in ST_Graphics.h
// nodes generated by application
#define SGN_TYPE_UNKNOWN	0
#define TYPE_PLANE_SHAPE	1
#define TYPE_OBSTACLE		2
#define TYPE_ROUTE_BORDER	3
#define TYPE_PES_OBJECT		4
#define TYPE_PLANE_APS		12
// nodes visible for application
#define SGN_TYPE_SUB_SHAPE	5
#define	SGN_TYPE_THERMAL	6
#define	SGN_TYPE_TIELEG		7
#define	SGN_TYPE_LIN_SEC	8
#define	SGN_TYPE_GEOM_LST	9
#define SGN_TYPE_PES_CUT	10

// nodes where use is defined by the application 
#define SGN_TYPE_APPL1		13 
#define	SGN_TYPE_OBJ_MAX	(SGN_TYPE_APPL1 + 1)

/////////////// GetHatchingParams modes //////////////////
// plane status
const unsigned int IS_PLANE_VISIBLE				= 0x00000001;
const unsigned int DISCARD_UNTIED_AREAS			= 0x00000002; // don't draw if not connected to metal ...
const unsigned int DO_NOT_CLEAR_TCS_OBJ			= 0x00000004; // don't clear buried vias from the metal in case of sharp angles
// Filling modes
const unsigned int HATCH_PATTERN				= 0x00000010; //  use Pattern filling
const unsigned int HATCH_NEGATIVE				= 0x00000020; // only for HATCH_PATTERN: fill outside of the pattern
const unsigned int HATCH_BOUND					= 0x00000040; // only for HATCH_PATTERN: fill Bound cells
const unsigned int HATCH_CROSS					= 0x00000080; // do cross hatch at the orthogonal angle
const unsigned int PARTIAL_HATCH_AREAS			= 0x00000100; // only for HATCH_CROSS: ...
const unsigned int RESTRICT_BOUNDARY_TO_PATTERN = 0x00000200; // only for orthogonal patterns
const unsigned int SNAP_TO_HATCH_GRID			= 0x00000400; // only for RESTRICT_BOUNDARY_TO_PATTERN:
// The SNAP_TO_HATCH_GRID value is relevent only the RESTRICT_BOUNDARY_TO_PATTERN 
// This will snap all clearance and hatch lines to the hatch grid. 
// The hatch grid is defined by the board origin and the hatch distance.
const unsigned int DRAW_SELECTED	= 0x00000800;
const unsigned int DRAW_STIPPLED	= 0x00001000;    
const unsigned int DRAW_HIGHLIGHTED = 0x00002000;    
const unsigned int DRAW_DOTTED		= 0x00004000;    
const unsigned int DRAW_PRIEVIEW	= 0x00008000; // for PES cuts
const unsigned int LPSM_TIE_BRIDGING= 0x00010000; // Bridging mode
const unsigned int HATCH_PATTERN2	= 0x00020000; // special filling for gerber

#endif	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~SGN_TYPE_OBJ_MAX

/////////////// obstacle type //////////////////
const unsigned int REGULAR_OBST		= 0x00000001;    
const unsigned int TCS_OBST			= 0x00000002;	// the trace connectivity shell

// Geometry nodes controller types
#define	SGN_CONT_TESTDB		0
#define	SGN_CONT_LPSM		1
#define	SGN_CONT_PSM		2
#define	SGN_CONN_MAP		3
#define	SGN_CONN_METAL		4
#define	SGN_CONN_THERM		5
#define	SGN_CONN_CELL		6

// geom types
#define	SGN_TYPE_GEOM_MIN	1000
#define	SGN_TYPE_GROUP		(SGN_TYPE_GEOM_MIN + 1)
#define	SGN_TYPE_POLY		(SGN_TYPE_GEOM_MIN + 2)
#define	SGN_TYPE_CIRCLE		(SGN_TYPE_GEOM_MIN + 3)
#define	SGN_TYPE_SEG		(SGN_TYPE_GEOM_MIN + 4)
#define	SGN_TYPE_ARC		(SGN_TYPE_GEOM_MIN + 5)
#define	SGN_TYPE_OCTADON_1	(SGN_TYPE_GEOM_MIN + 6)
#define	SGN_TYPE_BOX		(SGN_TYPE_GEOM_MIN + 7)
#define	SGN_TYPE_ARRAY		(SGN_TYPE_GEOM_MIN + 8)
#define	SGN_TYPE_ARRAY_ITEM	(SGN_TYPE_GEOM_MIN + 9)
#define	SGN_TYPE_LPOLY		(SGN_TYPE_GEOM_MIN + 10)
#define	SGN_TYPE_LCIRCLE	(SGN_TYPE_GEOM_MIN + 11)
#define	SGN_TYPE_SEL_NODE	(SGN_TYPE_GEOM_MIN + 12)
#define	SGN_TYPE_GEOM_MAX	(SGN_TYPE_SEL_NODE + 1)
#define	SGN_MARK 10000		// for tmp marker
#define	SGN_MARK_05 5000	// for tmp marker

// internal node flags
const unsigned short SGN_FLAG_SHELL		=	0x0001;
const unsigned short SGN_FLAG_PES		=	0x0002;
const unsigned short SGN_FLAG_IN_PS		=	0x0004;
const unsigned short SGN_FLAG_CENT		=	0x0008;
const unsigned short SGN_FLAG_HOLE		=	0x0010;
const unsigned short SGN_FLAG_DB		=	0x0020;	// dynamic
const unsigned short SGN_FLAG_PLANE		=	0x0040;
const unsigned short SGN_FLAG_SNET		=	0x0080;	// Same net
const unsigned short SGN_FLAG_TIELEG    =   0x0100; // tie leg
const unsigned short SGN_FLAG_MARKER1   =   0x0200; // simple marker1 (tmp)
const unsigned short SGN_FLAG_MARKER2   =   0x0400; // simple marker2 (tmp)
const unsigned short SGN_FLAG_TEMP      =   0x0800; // (tmp - mark for temporary objects)

const unsigned short SGN_FLAG_INVALID	=	0x1000;
const unsigned short SGN_FLAG_NOT_UTD	=	0x2000;	// is not Up To Date
const unsigned short SGN_FLAG_APS		=	0x4000;
const unsigned short SGN_FLAG_MSK_SYS	=	0xf000;
const unsigned short SGN_FLAG_MSK_APP	=	0x0fff;

class SYSGL_API GeomIter
{
public:
	//The  dll  will call the following virtual function to allow the client to control memory management
	virtual void	Destroy();

	// parent's properties
	virtual int		SetParent(GL_Node *parent, int layer); // initialization ???
	virtual GL_Node* GetParent();		// the parent of the GeomIter object 
	virtual GL_Node* GetCrnGeomNode();	// return the node of the current geom. item
	virtual int		GetType();		// to distinguish a plane shape from other pcb things, so only two types are enough: PLANE_SHAPE & NON_PLANE_SHAPE
	virtual int		GetSignal();	// to distinguish obstacles and same net pcb things
	virtual int		GetPcbHandle();   // to return handles in some requests (Connectivity and so on)
	virtual int		GetOrder(); // JS:  When two  Plane Shapes of different nets have intersection we use the order to determine which net the metal in the intersection will be on  (and which Plane Shape will pull back from the intersection).  Thus we need to update the higher priority PShapes first because the sub-shapes of the lower priority Plane Shapes are dependent upon them.
	virtual double	GetClearance(GL_Node *obj, int layer); // LPSM will request only clearances to the plane shape, so the parent of the iterator has PLANE_SHAPE type.
	virtual double	GetMaxClearance(int type, int layer);   // it is desirable to create such a method. It will improve LPSM generation. LPSM will use it only with PLANE_SHAPE type. It may return some global variable in the first version.
	virtual int		GetDrwParam(DrwFill *drw); // get parameters for drawing (color, pen, brush and so on), LPSM will use it only for plane shapes
	virtual int		GetPreSubNet();	// group of items
	virtual unsigned int IsObstacle(GL_Node *obj, int layer); // the parent of the iterator has PLANE_SHAPE type.
	// returned value has the one of the folowing flags:
	//	0				- ignore obstacle
	//  REGULAR_OBST	- regular obstacle
	//  TCS_OBST		- Trace Connectivity Shell. 
	//					- TCS is ignored in the sub shapes generation    
	//					- TCS is partially ignored in the graphics
	//					- TCS is used in the connectivity calculation
	virtual int		GetAreaSide();	// > 0 to the left; < 0 - to the right; 0 - is no a bound
	
	virtual int		IsTieLegRule();
	// The rule is the set of following conditions:
	//	- The preferred position’s angle of the first leg is equal to rotation
	//	- The angle between preferred positions of neighboring legs is (360 / preferredNumLegs)
	//	- The angle between preferred and real positions is less than tolerance
	//	- The rotation parameter means preferred rotation, if rotationFixed = false. In this case the real rotation is not restricted
	virtual int	GetTieLegRule( 
		GL_Node*	activePlaneRep,		// representative plane shape of active plane
		double&		legLength,			// 
		double&		legWidth,			// = iter->GetClearance(activePlaneRep);
		double&		rotation, 			// 0, 45, 90, 135 
		double&		tolerance,			// the allowable deviation of a tie leg 
		int&		preferredNumLegs,	// 4, 2, 0, -1 = Buried in plane.
		int&		rotationFixed		// true or false
	);
	virtual int GetPadOrigin (double &x, double &y);
	// returns 0 in case the object is not a pad

	virtual int GetDiscardAreaParams(
		int&	min_connections,	// discard_unconnected : if  the number of connections < min_connections.
        double&	min_area			// min_area: if positive, discard all subshapes having area
									// less than or equal to max_discardable_area.
	);
	virtual int GetMinCorners();	// the minimal number of corners on the boundary
	virtual int GetHatchingParams( 
		double&			angle,			// 90.0 - vertical, 0.0 - horizontal, 45.0 - Forward Slash. ...
		unsigned int&	modes,
		double&			width,			// the width of the hatch lines
		double&			dist,			// distance between center-lines of two hatch lines
		double&			minBoundryGap	// minimum distance allowed between boundary
										// lines in the plane (a.k.a. Minimum plane gap distance - see Plane Parmeters
										// dialog, stHatch Options tab.)
	);
	virtual int GetHatchOrigin (double &x, double &y);
	virtual int GetHatchArray(
		int &num_lines, // count of number of lines in the array (i.e. #points = 2 * num_lines)
		long *&points	// contains an array of LONGs. all in DBU (Data Base Units)
	);					// points = { x1, y1, x2, y2, ...xN, yN}, where N = num_lines
    // Note: UPG is responsible for memory contained in points. 
	// The application system is not allowed to modify the data.
	
	virtual GeomIter *GetExpandGeom(double dist); // dist = 0.0 - use width, the method should help to generate APS
	// Note: The application system is responsible for the iterator. It should perform Destroy() method
	// at the end of the iterator usage

	virtual int	CompareOrders(GL_Node *n2);		// (or CompareOrders(GL_Node *n1, GL_Node *n2))
	virtual int CompareOrder(GL_Node* plane_shape);  //Will return  +1  if the parent should be on top else  -1.
	virtual int IsMergable(GL_Node* plane_shape );  // returns  1  if the parent and plane_shape are to be merged, else 0.
 
	virtual GeomIter *GetFirstConnectedShape(GeomIter *itr2);
	virtual GeomIter *GetNextConnectedShape(GeomIter *itr2);
	
	////////////////////////////// Geometry
		//	 scanning
	virtual int		GetFirstGeom(); // get first geom. item - the chain of arcs and linear segments, or circle
	virtual int		GetNextGeom(); // get next polyline. It is desirable that  voids are scanned just after own outlines
	virtual int		GetCurrentId();	// get current polyline index

		// common parameters for any geometry item
	virtual int		IsClosed(); // current polyline is closed 
	virtual int		IsFilled(); // current polyline is filled. Example: two circles have the  same radius, but they have different filled status
	virtual int		IsHole();	// is the current polyline a hole?
	virtual double	GetWidth();	// get width of the current geom. item.
	virtual double	GetZ();		// get height of the current geom. item.
	virtual int		GetGeomType(); // get geom. type {polyline, PolyArc, circle, box, segment, octagon ...}.

		// Depending on the type of the current geometry, precisely one of the following functions will return non-zero.
	virtual int		GetCircle (double &xc, double &yc, double &rad); // get center (xc, yc) and radius of current circle
	virtual int		GetRectangle(double &xmin, double &ymin, double &xmax, double &ymax);
	virtual int		GetSegment(double &x1, double &y1, double &x2, double &y2,double &diam );
	virtual int		GetOctagon(double &xmin, double &ymin, double &xmax, double &ymax, double &d1, double &d2 );
	virtual int		GetFirstCrn(double &x, double &y); // get first corner of the current polyline, we also may use GetFirstCrn(long &x, long &y)

	// Get polyline or polyarc parameters
	virtual int		GetNextCrn(double &x, double &y); // get next corner of the current polyline, we also may use GetNextCrn(long &x, long &y). It is desirable that the  first and  the last points of closed polyline (polygon) are equal.
	virtual int		GetArc( double &xc, double &yc, double &rad); // for precision it's better  to keep  center or end points of the arc in double.

	// methods are supported for dll generated data, but are not required for application data
	virtual int		GetPointCount(); 
	virtual int		GetArcCount(); 

	// attach client's node to the sub shape.
	// return 0 in case:
	// - the current subshape is not defined,
	// - or the current subshape is already attached to some application node
	// Note: don't redefine this method on the client's level
	virtual int		AttachApplNode(GL_Node *appl_node);
	virtual GL_Node* GetApplNode();
	virtual int GetComponentHandle();	// for the scallops removing task
	virtual int GetRemoveScallops();	// for the scallops removing task
	virtual int PermitScallopRemoval();	// for the scallops removing task
public:	// debug
	void DumpGeom(char *file_name, char *mode = "w");
	void SetNode(GL_Node *parent, int layer);
//private:
	GL_Node*	parent;
	int			layer;
};	// GeomIter

///////////////////////GL_Node ///////////////////////////////////////////////
class SYSGL_API SGN_Controller
{
public:
	virtual int			CetControllerType();
	virtual void		CorrectOnChange(GL_Node *n, GL_Node *prev);
	virtual void		CorrectOnDelete(GL_Node *n, GL_Node *prev);
	virtual GeomIter	*GetGeomIter(GL_Node *n, int layer);
	virtual GeomIter	*GetShellIter(GL_Node *n, int layer, GL_Node *plain, double dist);
public:
	int		GetNet() {return net_id;}
	int		GetSubNet() {return subnet;}
	void	SetNet(int i) {net_id = i;}
	void	SetSubNet(int i) {subnet = i;}
	int net_id;
	int subnet;
};

//$$ Class: GL_Node
class SYSGL_API GL_Node
{
public:	// methods
	int				IsValid			() const;
	int				IsFirstChange	() const;
	int				IsGeomType		() const;
	int				IsInChain		(GL_Node *a_node);
	short			GetGeomType		() const;
	short			GetNodeType		() const;
	unsigned short	GetNodeFlags	() const;
    inline bool     IsNodeFlagSet	(unsigned short flag ) const;
	SGN_Controller*	GetSgnCont		() const;
	GL_Node*		GetRoot			() const;
	GL_Node*		GetNextRoot		(short type);
	GL_Node*		GetDBRoot		();
	GL_Node*		GetPrevRoot		(GL_Node	*n = NULL);
	GL_Node*		GetBeforeType	(short a_type);
	GL_Node*		GetByType		(short a_type);
	GL_Node*		GetByFlag		(unsigned short a_flag);
	GL_Node*		GetNextGeom		();
	GeomIter*		GetGeomIter		(int layer);
	GeomIter*		GetShellIter	(int layer, GL_Node *plain, double dist);
	void			Invalidate		();
	void			Init0			();
	void			SetNodeType		(short a_type);
	void			SetGeomType		(short a_type);
	void			SetNodeFlags	(unsigned short a_flag);
	void			AddNodeFlags	(unsigned short a_flag);
	void			DelNodeFlags	(unsigned short a_flag);
	void			SetSgnCont		(SGN_Controller *a_cont);
	void			SetRoot			(GL_Node *a_node);
	void			IncludeRoot		(GL_Node *a_node);
	GL_Node*		Exclude			();
	GL_Node*		ExcludeRoot		();
	GL_Node*		ExcludeByType	(short a_type, GL_Node **rem);
	GL_Node*		ExcludeByFlag	(unsigned short fl, GL_Node **rem);
	void			OnChange		(GL_Node *prev = NULL);
	void			OnDelete		(GL_Node *prev = NULL);
	void			CorrectOnChange	(GL_Node *prev = NULL);
	void			CorrectOnDelete	(GL_Node *prev = NULL);
	GL_Node*		ChkGeomNode		(char *chk_mode = "ZI", char *fname = NULL);	// Zero ptr & Intermal loops
	char*			StrNode();

protected:
	int		IsMarkSgn	(const GL_Node *n) const;
	void	MarkSgn		(GL_Node *n); 
	void	UnMarkSgn	(GL_Node *n); 
	GL_Node				();

private:		// data
	GL_Node*		sgn_root;	// database object, temp. object, etc.
	unsigned short	sgn_flags;	// {is_valid, is_changed, is_shell, ... }
	short			sgn_type;	// < 0 - geom {circle, polyline, etc}, > 0 - DB {copper, trace, etc}
	SGN_Controller*	sgn_cont;
};

inline GL_Node::GL_Node ()
{
	sgn_root	= this;
	sgn_cont	= NULL;
	sgn_type	= 0;
	sgn_flags	= 0;
};
inline void GL_Node::Init0 ()
{
	sgn_root	= this;
	sgn_cont	= NULL;
	sgn_type	= 0;
	sgn_flags	= 0;
};

inline int	GL_Node::IsMarkSgn (const GL_Node *n) const
{
	//return (n && n->sgn_type < 0)? 1 : 0;
	return (n && n->sgn_type > SGN_MARK_05)? 1 : 0;
}
inline void GL_Node::MarkSgn(GL_Node *n)
{
	//if (n && n->sgn_type > 0) n->sgn_type = -n->sgn_type;
	if (n && n->sgn_type < SGN_MARK_05) n->sgn_type += SGN_MARK;
}
inline void GL_Node::UnMarkSgn(GL_Node *n)
{
	//for (; n && n->sgn_type < 0; n = n->sgn_root) n->sgn_type = -n->sgn_type;
	for (; n && n->sgn_type > SGN_MARK_05; n = n->sgn_root) n->sgn_type -= SGN_MARK;
}

inline SGN_Controller *GL_Node::GetSgnCont() const
{
	return sgn_cont;
}
inline void GL_Node::SetSgnCont (SGN_Controller *a_cont)
{
	sgn_cont = a_cont;
}
inline GeomIter *GL_Node::GetGeomIter(int layer)
{
	return (sgn_cont)? sgn_cont->GetGeomIter(this, layer) : NULL;
}
inline GeomIter	*GL_Node::GetShellIter(int layer, GL_Node *plain, double dist)
{
	return (sgn_cont)? sgn_cont->GetShellIter(this, layer, plain, dist) : NULL;
}

inline void	GL_Node::Invalidate()
{
	sgn_flags |= SGN_FLAG_INVALID;
	//sgn_root = this;
}
inline void	GL_Node::OnChange(GL_Node *prev)
{
	if(IsFirstChange()) {
		sgn_flags |= SGN_FLAG_NOT_UTD;
		//ChkGeomNode();	// _DEBUG 0
		sgn_root->OnChange(this);    // recursive call
		CorrectOnChange(prev);    // it depends of the node type
   }
}

inline void GL_Node::CorrectOnChange(GL_Node *prev)
{
	if (sgn_cont) sgn_cont->CorrectOnChange(this, prev);
}
inline void	GL_Node::CorrectOnDelete(GL_Node *prev)
{
	if (sgn_cont) sgn_cont->CorrectOnDelete(this, prev);
}

//So each nodes in the loop will receive the notification before changes. In our case cPcbThing will send OnChange() notification, LPSM will destroy all shells corresponded to this cPcbThing (or will keep old shells for the future GetDifferences() operations), but will keep nodes in the special list. 
//LPSM will run Update() on the requests like Draw(). It will check special list and will generate new shells.
 
inline void	GL_Node::OnDelete(GL_Node *prev)
{
	if(IsValid()) {
		//ChkGeomNode();	// _DEBUG 0
		Invalidate();
		if (sgn_root && sgn_root != this) sgn_root->OnDelete(this);
		sgn_flags &= ~SGN_FLAG_INVALID;
		CorrectOnDelete(prev);        
	}
}
inline int GL_Node::IsValid() const
{
	return (sgn_flags & SGN_FLAG_INVALID)? 0 : 1;
}
inline int GL_Node::IsFirstChange() const
{
	return (sgn_flags & SGN_FLAG_NOT_UTD)? 0 : 1;
}
inline int GL_Node::IsGeomType() const
{
	return (sgn_type > SGN_TYPE_GEOM_MIN);
}
inline short GL_Node::GetGeomType() const
{
	return sgn_type;
}
inline short GL_Node::GetNodeType() const
{
	return sgn_type;
}
inline unsigned short GL_Node::GetNodeFlags () const
{
	return sgn_flags;
}

inline bool GL_Node::IsNodeFlagSet( unsigned short flag ) const
{
    return (flag & sgn_flags)!=0;
}

inline GL_Node	*GL_Node::GetRoot() const
{
	return sgn_root;
}
inline GL_Node	*GL_Node::GetBeforeType (short type)
{
	GL_Node	*n = this;
	for(; n && n->sgn_root; n = n->sgn_root) {
		if (IsMarkSgn(n)) {
			break;
		}
		if (n->sgn_root->sgn_type == type) {
			UnMarkSgn(this);
			return n;
		}
		MarkSgn(n);
	}
	UnMarkSgn(this);
	return NULL;
}

inline GL_Node	*GL_Node::GetNextRoot (short type)
{
	GL_Node	*n = sgn_root;
	for(; n && n != this; n = n->sgn_root) {
		if (IsMarkSgn(n)) {
			break;
		}
		if (n->sgn_type == type) {
			UnMarkSgn(sgn_root);
			return n;
		}
		MarkSgn(n);
	}
	UnMarkSgn(sgn_root);
	return NULL;
}
inline GL_Node	*GL_Node::GetDBRoot ()
{
	if (sgn_flags & SGN_FLAG_DB) return this;
	GL_Node *n = sgn_root;
	for(; n && n != this; n = n->sgn_root) {
		if (IsMarkSgn(n)) {
			break;
		}
		if (n->sgn_flags & SGN_FLAG_DB) {
			UnMarkSgn(sgn_root);
			return n;
		}
		MarkSgn(n);
	}
	UnMarkSgn(sgn_root);
	return NULL;
}
inline int	GL_Node::IsInChain(GL_Node *node)
{
	GL_Node *n = this;
	for(; n; n = n->sgn_root) {
		if (IsMarkSgn(n)) {
			break;
		}
		if (n == node) {
			UnMarkSgn(this);
			return 1;
		}
		MarkSgn(n);
	}
	UnMarkSgn(this);
	return 0;
}

inline GL_Node	*GL_Node::GetPrevRoot (GL_Node	*node)
{
	if (node == NULL) node = this;
	GL_Node	*n = node;
	for(; n; n = n->sgn_root) {
		if (IsMarkSgn(n)) {
			break;
		}
		if (n->sgn_root == node) {
			UnMarkSgn(node);
			return n;
		}
		MarkSgn(n);
	}
	UnMarkSgn(node);
	return NULL;
}

inline void	GL_Node::SetNodeType (short a_type)
{
	sgn_type = a_type;
}
inline void	GL_Node::SetGeomType (short a_type)
{
	sgn_type = a_type;
}
inline void GL_Node::SetNodeFlags (unsigned short a_flag)
{
	sgn_flags = a_flag;
}
inline void GL_Node::AddNodeFlags (unsigned short a_flag)
{
	sgn_flags |= a_flag;
}
inline void GL_Node::DelNodeFlags (unsigned short a_flag)
{
	sgn_flags &= ~a_flag;
}
inline void	GL_Node::SetRoot (GL_Node *a_node)
{
	sgn_root = a_node;
}
inline void	GL_Node::IncludeRoot (GL_Node *a_node)
{
	if (a_node) {
		a_node->sgn_root = sgn_root;
		sgn_root = a_node;
	}
};

inline GL_Node *GL_Node::Exclude ()
{
	GL_Node *prev = GetPrevRoot();
	if (prev) {
		return prev->ExcludeRoot();
	}
	//ChkGeomNode();
	sgn_root = this;
	return NULL;
}
inline GL_Node *GL_Node::ExcludeRoot ()
{
	if (sgn_root && sgn_root != this) {
		GL_Node *n = sgn_root;
		sgn_root = sgn_root->sgn_root;
		n->sgn_root = n;
		return n;
	}
	return NULL;
};

class ConnGraphIter
{
public:
	virtual void			Destroy();
	virtual int				GetSrcVertex(unsigned int type_flag, GL_Node* ParentPlaneShape);
	virtual int				GetSrcVertex(unsigned int type_flag, int net);
	virtual int				GetFirstTrg(unsigned int type_flag);
	virtual int				GetNextTrg();
	virtual int				GetPrevTrg();
	virtual int				GetTrgType();
	
	// swap src & target vertices
	virtual int				GoToTrg();
	
	// return 0 in case:
	// - the current vertex does not have the geometry
	virtual GeomIter		*GetGeometry();

	// return 0 in case:
	// - the client node does not attached to the vertex
	virtual GL_Node	*GetApplNode();

	// attach client's node to the current vertex
	// return 0 in case:
	// - the current vertex does not permit an attachment
	// - or the current subshape is already attached to some application node
	
	virtual int		AttachApplNode(GL_Node *appl_node);
	//virtual void	MarkSrc(); ??
	//virtual void	MarkTrg();
	// virtual int IsMarked();

	// in case trg is SameNetVtx
	int GetNet();
	int GetSubNet();
	int IsTherm();
	int GetTieLegRule();
	int GetTieLeg(int &id, double &x1, double &y1, double &x2, double &y2);
};

//~~*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
class DB_Area;
class GeomHdr;
class SYSGL_API Area
{
public:
	Area();
	~Area();
	int		AddObj(GL_Node *obj);
	int		DelObj(GL_Node *obj);
	int		Clear();
	void	Destroy();
	
	Area	*Invert();
	Area	*Merge		(Area *a, Area *b);
	Area	*Subtract	(Area *a, Area *b);
	Area	*Cross		(Area *a, Area *b);
	Area	*ExclusiveOr(Area *a, Area *b);
	
	Area	*Expand(double dist);
	Area	*ChamferedExpand(double dist, double corner_dist, double max_angle = 91.0);
	Area	*RemoveHoles();	// Convert to mentorgon()
	Area	*RemoveArcs(double eps, int mode);
	void	DefinePolygonTypes();


	GeomIter	*GetAreaIter();
	long		*GetHatchArray(int &num);    
	double		GetLength();
	double		GetArea();
	// debug
	GeomHdr *AddList(GeomHdr *gh);
private:
	DB_Area *Create();
	DB_Area *db_area;
};

#endif	// _GEOM_ITER_H_

