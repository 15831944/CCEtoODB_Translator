// $Header: /CAMCAD/5.0/read_wrt/DdeIn.cpp 82    3/12/07 12:50p Kurt Van Ness $

/****************************************************************************/
/*  
   Project CAMCAD                                     
   Router Solutions Inc.
   Copyright © 1994-2000. All Rights Reserved.

   according to DDE mentor manual

   Article == partnumber == ATT_TYPEDEVICE
   type    == geom       == 
*/           

#include "stdafx.h"
#include "ccdoc.h"
#include "dbutil.h"
#include "graph.h"             
#include "geomlib.h"
#include "pcbutil.h"
#include "polylib.h"
#include "format_s.h"
#include <math.h>
#include <string.h>
#include "gauge.h"
#include "attrib.h"
#include "net_util.h"
#include "ddein.h"
#include "CCEtoODB.h"
#include "RwUiLib.h"

extern CProgressDlg *progress;
//extern LayerTypeInfoStruct layertypes[];
//extern void ExplodeInsert(CCEtoODBDoc *doc, DataStruct *data, CDataList *dataList); // from explode.cpp

#define   MAX_LAYER           256

/* Prototype Section ****************************************************/
static int go_ipl(List *tok_lst,int lst_size);
static int tok_search(List *tok_lst,int tok_size);
static double ipl_unit(double);     /* converts Unit any unit into pageUnits */
static int get_slistptr(int s);
static double conv_rotation(char *lp);
static int layer_type(int laynr, int mirror);
static int write_graph();
static int update_padstackname(const char *l);
static int get_compptr(int compnr);
static char *get_shapename(int s);
static int get_shapeptr(int compnr);
static int get_padshape(int code);
static char *get__layername(int l, char *lname);
static int update_padname(char *padname, int padcode, int laynr, int rot);
static int write_padgraph(const char *apname);
static int do_layer();
static int get_layerindex_from_name(const char *l);
static int get_fill_from_curdfa();
static int load_iplsettings(const CString fname);
static void clean_polys(CDataList *DataList, double small_element);
static int change_refnames();
static int GetPadstackName(int padstackNum, CString &padstackName, BOOL isCompMirrored);
static int get_drillindex(double size, BOOL plated);
static int IsLpmLayerMapped(CString layerName);
static void Graph_Polygon(CString polygonName, CPolyList *polyList);

/* Globals ****************************************************************/

static CCEtoODBDoc *doc;
static FILE       *ifp, *ferr;
static int        pageunits;
static int        display_error = 0;
static long       linecnt = 0;                    /* Current line number. */
static char       token[MAX_LINE];
static char       line[MAX_LINE];

static FileStruct *file = NULL;
static int        ipl_file_end;
static int        cur_state = STAT_UNKNOWN;
static CString    cur_name;
static CString    cur_netname;

static CGraphArray   grapharray;
static int        graphcnt;

static CSlistArray   slistarray;
static int        slistcnt;

static CPadshapeArray   padshapearray;
static int        padshapecnt;

static CPstArray  pstarray;
static int        pstcnt;

static CCompArray  complistarray;
static int        complistcnt;

static CLlistArray llistarray;
static int        llistcnt;

static CPadstackArray padstackArray;
static int        padstackCnt;

static CStringArray ulsArray;
static int        ulsCnt;

static CStringArray padstacknamearray; // D:x,L:y <--- generated by reader
static int        padstacknamecnt;

static CPadArray  padarray;
static int        padcnt;

static DataStruct *cur_data;
static DataStruct *cur_dfadata;

static int        savegrpwise = FALSE;
static int        fastsave    = TRUE;

static CString    PADSTACK_POLYGON;
static CString    TRACK_POLYGON;

static int        cur_trackcode;
static int        cur_dfaon = FALSE;
static CString    cur_dfatyp;
static bool			cur_dfa_has_traces = false;

static DDEAdef    layer_attr[MAX_LAYER];       /* Array of layers from pdif.in   */
static int        layer_attr_cnt;

static CDrillArray   drillarray;
static int        drillcnt;

static CAttribmapArray  attribmaparray;
static int        attribmapcnt = 0;

static CLpmArray  lpmarray;
static int        lpmcnt = 0;

static DDEPinl     pinl[MAX_LAYER];

static double     cur_offset_x;
static double     cur_offset_y;

static CString    mastercomp;   // used for .pop
static CString    masterpin;
static DataStruct *masterdata;

// Variables used for ipl settings in ".in" file
static int        REFNAME_LAYER;
static int        EXPLODE_BOARDKIND;
static int        PADSTACKJOB;         // set to false if a design was not design with padstacks.
static CString    PADSHAPE_PREFIX;     // Specify a pad shape name prefix to be added the the padshape name
static BOOL       AltComTxt;
static BOOL       HatchLineFill;

static int        ComponentSMDrule;    // 0 = take existing ATT_SMD
                                          // 1 = if all pins of comp are marked as SMD
                                          // 2 = if most pins of comp are marked as SMD
                                          // 3 = if one pin of comp are marked as SMD


/******************************************************************************
* ReadDDE
*/
void ReadDDE(const char *path_buffer, CCEtoODBDoc *Doc, FormatStruct *Format, int PageUnits)
{
   doc = Doc;
   file = NULL;
   display_error = FALSE;
   pageunits = PageUnits;


   // this can not be rt (because of LB terminator)
   if ((ifp = fopen(path_buffer, "r")) == NULL)
   {
      CString msg;
      msg.Format("Error open [%s] file", path_buffer);
      ErrorMessage(msg, "Error");
      return;
   }

   CString ddeLogFile = GetLogfilePath("dde.log");
   if ((ferr = fopen(ddeLogFile, "wt")) == NULL)
   {
      CString msg;
      msg.Format("Error open [%s] file", ddeLogFile);
      ErrorMessage(msg, "Error");
      return;
   }

   slistarray.SetSize(100, 100);
   slistcnt = 0;

   padshapearray.SetSize(100, 100);
   padshapecnt = 0;

   pstarray.SetSize(100, 100);
   pstcnt = 0;

   grapharray.SetSize(100, 100);
   graphcnt = 0;

   complistarray.SetSize(100, 100);
   complistcnt = 0;

   padstackArray.SetSize(100, 100);
   padstackCnt = 0;

   ulsArray.SetSize(10, 10);
   ulsCnt = 0;

   padstacknamearray.SetSize(100, 100);
   padstacknamecnt = 0;

   padarray.SetSize(100, 100);
   padcnt = 0;

   llistarray.SetSize(100, 100);
   llistcnt = 0;

   drillarray.SetSize(100, 100);
   drillcnt = 0;

   attribmaparray.SetSize(100, 100);
   attribmapcnt = 0;

   lpmarray.SetSize(100, 100);
   lpmcnt = 0;

   // initialize the MAX_Layer list
	int i=0; 
   for (i=0; i<MAX_LAYER; i++)
   {
      DDELlist *list = new DDELlist;
      llistarray.SetAtGrow(llistcnt++, list);  
      list->name.Format("L%d", i);
      list->defined = FALSE;
      list->index = i;
      list->mirrorindex = i;
      list->stacknumber = 0;
      list->electrical = 0;
      list->inner =  0;
      list->layer_type = 0;
      list->plane = 0;
      list->solder = 0;
      list->comp = 0;
   }

   file = Graph_File_Start(path_buffer, Type_DDE_Layout);
   file->setBlockType(blockTypePcb);
   file->getBlock()->setBlockType(file->getBlockType());
   Graph_Level("0", "", 1);

   savegrpwise = FALSE; // init here
   fastsave = TRUE;
   PADSTACK_POLYGON = "electricpolygon";
   TRACK_POLYGON = "plotterpolygon";
   cur_dfaon = FALSE;
   cur_dfatyp = "";
   cur_offset_x = 0;
   cur_offset_y = 0;
   cur_netname = "";

   CString settingsFile( getApp().getImportSettingsFilePath("dde.in") );
   CString settingsFileMsg;
   settingsFileMsg.Format("\nDDE Reader: Settings file [%s].\n", settingsFile);
   getApp().LogMessage(settingsFileMsg);
   load_iplsettings(settingsFile);

   linecnt = 0;
   ipl_file_end = 1; // every .rem has it's own .end

   go_ipl(pcb_lst, SIZ_PCB_LST);
   do_layer();
   clean_polys(&file->getBlock()->getDataList(), 0.0001);

   // must be after layer typing.
   update_smdpads(doc);
   RefreshInheritedAttributes(doc, SA_OVERWRITE);  // smd pins are after the pin instance is done.
   change_refnames();
   update_smdrule_geometries(doc, ComponentSMDrule);
   update_smdrule_components(doc, file, ComponentSMDrule);

   int err = check_primary_boardoutline(file);
   switch (err)
   {        
   case 1:
      fprintf(ferr, "Primary Boardoutline found, but not closed!\n");
      display_error++;
      break;
   case 2:
      fprintf(ferr, "No Primary Boardoutline found!\n");
      display_error++;
      break;
   case 3:
      fprintf(ferr, "One Primary closed Boardoutline and multiple open elements found!\n");
      fprintf(ferr, "The open elements will be set to BOARD GEOMETRIES!\n");
      display_error++;
      break;
   case 4:
      fprintf(ferr, "Multiple Primary closed Boardoutline and multiple open elements found!\n");
      fprintf(ferr, "All elements will be set to BOARD GEOMETRIES!\n");
      display_error++;
      break;
   }

   EliminateSinglePointPolys(doc);                
   if (!savegrpwise)
      ErrorMessage("Design was saved Groupwise N. This will not assign a netlist to Traces.\nSave design again or Derive Netlist within CAMCAD!", "No Netlist assigned to Traces");
   fclose(ifp);

   for (i=0; i<attribmapcnt; i++)
      delete attribmaparray[i];
   attribmaparray.RemoveAll();
   attribmapcnt = 0;

   for (i=0; i<lpmcnt; i++)
      delete lpmarray[i];
   lpmarray.RemoveAll();
   lpmcnt = 0;

   for (i=0; i<slistcnt; i++)
      delete slistarray[i];  
   slistarray.RemoveAll();
   slistcnt = 0;

   for (i=0; i<padshapecnt; i++)
      delete padshapearray[i];  
   padshapearray.RemoveAll();
   padshapecnt = 0;

   for (i=0; i<pstcnt; i++)
      delete pstarray[i];  
   pstarray.RemoveAll();
   pstcnt = 0;

   for (i=0; i<complistcnt; i++)
      delete complistarray[i];  
   complistarray.RemoveAll();
   complistcnt = 0;

   for (i=0; i<padstackCnt; i++)
      delete padstackArray[i];  
   padstackArray.RemoveAll();
   padstackCnt = 0;

   ulsArray.RemoveAll();
   ulsCnt = 0;

   padstacknamearray.RemoveAll();
   padstacknamecnt = 0;

   for (i=0; i<padcnt; i++)
      delete padarray[i];  
   padarray.RemoveAll();
   padcnt = 0;

   for (i=0; i<llistcnt; i++)
      delete llistarray[i];  
   llistarray.RemoveAll();
   llistcnt = 0;

   grapharray.RemoveAll();
   fclose(ferr); 
   if (display_error)
      Logreader(ddeLogFile);

   return;
}

/******************************************************************************
* ipl_sec
*  Secret shape ???
*/
static int ipl_sec()
{
   return 1;
}

/******************************************************************************
* ipl_bma
*/
static int ipl_bma()
{
// added in order to map non associated lmp to the layer list.
   for (int i = 0; i<lpmcnt; i++)
   {
      DDELpm *lpmLayer = lpmarray[i];
      if (!IsLpmLayerMapped(lpmLayer->name))
      {
         int layerIndex = Graph_Level(lpmLayer->name,"",0);
         DDELlist *layerlist = new DDELlist;
         llistarray.SetAtGrow(llistcnt++, layerlist);  
         layerlist->defined = TRUE;
         layerlist->name = lpmLayer->name;
         layerlist->lpmname = lpmLayer->name;
         layerlist->index = llistcnt-1;
         layerlist->mirrorindex = llistcnt-1;
         layerlist->stacknumber = 0;
         layerlist->electrical = 0;
         layerlist->inner =  0;
         layerlist->layer_type = 0;
         layerlist->plane = 0;
         layerlist->solder = 0;
         layerlist->comp = 0;
      }
   }
    return 1;
}

/******************************************************************************
* ipl_cle
*/
static int ipl_cle()
{
   return 1;
}

/******************************************************************************
* ipl_iad
*   ?? what is this.
*/
static int ipl_iad()
{
   //cur_iad = TRUE;
   return 0;
}

/******************************************************************************
* ipl_tol
*/
static int ipl_tol()
{
   // skip
   return 1;
}

/******************************************************************************
* ipl_pul
*/
static int ipl_pul()
{
   // skip
   return 1;
}

/******************************************************************************
* ipl_fon
*/
static int ipl_fon()
{
   // skip
   return 1;
}

/******************************************************************************
* ipl_dop
*/
static int ipl_dop()
{
   // skip
   return 1;
}

/******************************************************************************
* ipl_pla
*/
static int ipl_pla()
{
   // skip
   return 1;
}

/******************************************************************************
* ipl_pst
*/
static int ipl_pst()
{
   char  *lp;

   cur_state = STAT_PADSTACK;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   int padstackNum = atoi(lp);

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double drillSize = ipl_unit(atof(lp));

   BOOL plated = FALSE;
   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   if (lp[0] == 'p' || lp[0] == 'P')
      plated = TRUE;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   if ((lp = strtok(NULL, " \t\n")) == NULL)  // if SMD padstack, not all layers will be used.
      return 0;
   char stackType = lp[0];

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   CString padstackName = lp;

   // Make sure that the padstack name is not already used; otherwise it will cause a lot of problem
   CString tmpName = padstackName;
   int count = 0;
   while (Graph_Block_Exists(doc, tmpName, -1))
   {
      tmpName.Format("%s_%d", padstackName, count++);
   }
   padstackName = tmpName;

   BlockStruct *block = Graph_Block_On(GBO_APPEND, padstackName, -1, 0);
   block->setBlockType(BLOCKTYPE_PADSTACK);

   if (drillSize > 0)
   {
      int layIndex = Graph_Level("DRILLHOLE", "", 0);
      LayerStruct *layer;
      if (layer = doc->FindLayer(layIndex))
      {
         layer->setComment("Drill");
         layer->setLayerType(LAYTYPE_DRILL);
      }

      int drillIndex = get_drillindex(drillSize, plated);
      if (drillIndex > -1)
      {
         CString drillName;
         drillName.Format("DRILL_%d", drillIndex);
         Graph_Block_Reference(drillName, NULL, 0, 0.0, 0.0, 0.0, 0, 1.0, layIndex, TRUE);
      }
   }
   Graph_Block_Off();

   DDEPadstack *padstack = new DDEPadstack;
   padstack->padstackNum = padstackNum;
   padstack->drillSize = drillSize;
   padstack->padstackName = padstackName;
   padstack->creatFlag = 0;
   padstack->stackType = stackType;
   padstackArray.SetAtGrow(padstackCnt++, padstack);

   return 1;
}

/******************************************************************************
* ipl_uls
*/
static int ipl_uls()
{
   char *lp;
   if ((lp = strtok(NULL, "\n")) == NULL)
      return 0;
   CString ulsString = lp;

   if (cur_state == STAT_PADSTACK)
      ulsArray.SetAtGrow(ulsCnt++, ulsString);

   return 0;
}

/******************************************************************************
* PrepareULSArray

   This function check to see if a padstack is SMD or not, if it is SMD then do the followings:
   1) For each entry in ulsArray, find its corresponding mirrored layer in the ulsArray
   2) Then find out the surface (top/bottom) of the two layers
   3) Then find out if the two layers use different padshapes
      If they do then
         - copy the original layers to two new layers
         - make the top layer NEVER MIRROR
         - make the bottom layer MIRROR ONLY
      If they don't then
         - remove the entry for the bottom layer
*/
void PrepareULSArray()
{
   // Get the last padstack define
   DDEPadstack *padstack = padstackArray[padstackCnt-1];

   if (padstack->stackType != 's')
      return;

   for (int i=0; i<ulsCnt; i++)
   {
      CString ulsString = ulsArray[i];
      CString lp;
      int curPos = 0;

      if (ulsString.Right(1) == char(5))
         continue;

      if ((lp = ulsString.Tokenize(" \t\n", curPos)) == "")
         continue;
      if (lp[0] == '\'')
      {
         if ((lp = ulsString.Tokenize("'", curPos)) == "")
            continue;
      }
      CString lmpLayerName = lp;

      if ((lp = ulsString.Tokenize(" \t\n", curPos)) == "")
         continue;
      CString shapeNum = lp;
      shapeNum.Trim();

      if (shapeNum.IsEmpty())
      {
         ulsArray[i].Empty();
         continue;
      }
      else
      {
         //Indicate the element is already looked at by appending chr(5)
         ulsArray[i].AppendChar(char(5));
      }

      for (int ii=0; ii<llistcnt; ii++)   
      {
         // One lmpName can map to more than one layers
         // so do all the layers that match the lmpName
         DDELlist *ddeLayer = llistarray[ii];
         if (STRCMPI(ddeLayer->lpmname, lmpLayerName))   //Find the associated lmp layer
            continue;
         if (ddeLayer->index == ddeLayer->mirrorindex)   //Make sure the layer is not mirrored to itself
            continue;

         DDELlist *ddeMirLayer = llistarray[ddeLayer->mirrorindex];

         // For each entry in ulsArray, find its corresponding mirrored layer in the ulsArray
         for (int k=i+1; k<ulsCnt; k++)
         {
            CString ulsString2 = ulsArray[k];
            CString lp2;
            int curPos2 = 0;

            if ((lp2 = ulsString2.Tokenize(" \t\n", curPos2)) == "")
               continue;
            if (lp2[0] == '\'')
            {
               if ((lp2 = ulsString2.Tokenize("'", curPos2)) == "")
                  continue;
            }
            CString lmpLayerName2 = lp2;

            if ((lp2 = ulsString2.Tokenize(" \t\n", curPos2)) == "")
               continue;
            CString shapeNum2 = lp2;
            shapeNum2.Trim();

            if (shapeNum2.IsEmpty())
            {
               ulsArray[k].Empty();
               continue;
            }

            if (lmpLayerName2 != ddeMirLayer->lpmname)
               continue;

            //Indicate the element is already looked at by appending chr(5)
            ulsArray[k].AppendChar(char(5));


            // Find out if the two layers use different padshapes
            if (shapeNum2 == shapeNum)
            {
               //The lmp layer and its mirror layer are using the same shapes, so remove the bottom layer
               if (ddeLayer->isBottomLayer)
                  ulsArray[i].Empty();
               else if (ddeMirLayer->isBottomLayer)
                  ulsArray[k].Empty();
            }
            else if (shapeNum2 != shapeNum)
            {
               //The lmp layer and its mirror layer are NOT using the same shapes, so create new layer

               CString layerName = "";
               CString mirLayerName = "";
               LayerStruct *tmpLayer = NULL;
               LayerStruct *tmpMirLayer = NULL;

               //Find out which layer is top/bottom
               if (!ddeLayer->isBottomLayer)
               {
                  LayerStruct *tmpLayer = doc->FindLayer_by_Name(ddeLayer->name);
                  LayerStruct *tmpMirLayer = doc->FindLayer_by_Name(ddeMirLayer->name);

                  layerName.Format("%s_NM", ddeLayer->name);
                  mirLayerName.Format("%s_MO", ddeMirLayer->name);

                  //Replace the top and bottom layers with the corresponding new layers
                  ulsArray[k].Replace(lmpLayerName2, layerName);
                  ulsArray[i].Replace(lmpLayerName, mirLayerName);
               }  
               else
               {
                  LayerStruct *tmpLayer = doc->FindLayer_by_Name(ddeMirLayer->name);
                  LayerStruct *tmpMirLayer = doc->FindLayer_by_Name(ddeLayer->name);

                  layerName.Format("%s_NM", ddeMirLayer->name);
                  mirLayerName.Format("%s_MO", ddeLayer->name);

                  //Replace the top and bottom layers with the corresponding new layers
                  ulsArray[i].Replace(lmpLayerName, layerName);
                  ulsArray[k].Replace(lmpLayerName2, mirLayerName);
               }  

               //Create the new layers by copying the original ones
               // - make the top layer NEVER MIRROR
               CString tmpLayerName;

               LayerStruct *layer = NULL;
               if (tmpLayer == NULL)
                  continue;
               memcpy(layer, tmpLayer, sizeof(LayerStruct));
               tmpLayerName.Format("%s_NM", tmpLayer->getName());
               layer->setName(tmpLayerName);
               layer->setFlagBits(LY_NEVERMIRROR);
               layer->getAttributesRef() = new CAttributes();
               doc->CopyAttribs(&layer->getAttributesRef(), tmpLayer->getAttributesRef());
            
               // - make the bottom layer MIRROR ONLY
               LayerStruct *mirLayer = NULL;
               memcpy(mirLayer, tmpMirLayer, sizeof(LayerStruct));
               tmpLayerName.Format("%s_MO", tmpMirLayer->getName());
               mirLayer->setName(tmpLayerName);
               mirLayer->setFlagBits(LY_MIRRORONLY);
               mirLayer->getAttributesRef() = new CAttributes();
               doc->CopyAttribs(&mirLayer->getAttributesRef(), tmpMirLayer->getAttributesRef());

               //Add the layer association to the llistarray
               DDELlist *layerlist = new DDELlist;
               layerlist->defined = TRUE;
               layerlist->name = layer->getName();
               layerlist->lpmname = layer->getName();
               layerlist->index = llistcnt;
               layerlist->mirrorindex = llistcnt + 1;
               layerlist->stacknumber = 0;
               layerlist->electrical = 0;
               layerlist->inner =  0;
               layerlist->layer_type = 0;
               layerlist->plane = 0;
               layerlist->solder = 0;
               layerlist->comp = 0;
               llistarray.SetAtGrow(llistcnt++, layerlist);  
   
               DDELlist *mirLayerList = NULL;
               memcpy(mirLayerList, layerlist, sizeof(DDELlist));
               mirLayerList->name = mirLayer->getName();
               mirLayerList->lpmname = mirLayer->getName();
               mirLayerList->index = llistcnt;
               mirLayerList->mirrorindex = llistcnt - 1;
               llistarray.SetAtGrow(llistcnt++, mirLayerList);  
            }

            //Found the mirrored lmp so break
            break;
         }
      }
   }
}

/******************************************************************************
* ipl_pse
*/
static int ipl_pse()
{
   if (cur_state != STAT_PADSTACK)
      return 1;

   PrepareULSArray();

   // Get the last padstack define
   DDEPadstack *padstack = padstackArray[padstackCnt-1];

   Graph_Block_On(GBO_APPEND, padstack->padstackName, -1, 0);
   for (int i=0; i<ulsCnt; i++)
   {
      // Loop through the array of uls definition
      CString tmpString = ulsArray[i];
      CString lp;
      int curPos = 0;

      if (tmpString.Right(1) == char(5))
         tmpString.Remove(char(5));

      if ((lp = tmpString.Tokenize(" \t\n", curPos)) == "")
         continue;
      if (lp[0] == '\'')
      {
         if ((lp = tmpString.Tokenize("'", curPos)) == "")
            continue;
      }
      CString lmpLayerName = lp;

      int shapeNum = -1;
      if ((lp = tmpString.Tokenize(" \t\n", curPos)) == "")
         continue;
      shapeNum = atoi(lp);

      while (shapeNum > -1)   
      {
         // There can be more than one padshape number insert on the same lmpName
         // so insert all the padshape

         for (int i=0; i<llistcnt; i++)   
         {
            // One lmpName can map to more than one layers
            // so do all the layers that match the lmpName
            DDELlist *ddeLayer = llistarray[i];
            if (STRCMPI(ddeLayer->lpmname, lmpLayerName))
               continue;

            // Graph the layer
            CString ccLayerName;
            int layIndex;
            LayerStruct *layer = doc->FindLayer_by_Name(lmpLayerName);
            if (layer)
            {
               ccLayerName = lmpLayerName;
               layIndex = layer->getLayerIndex();
            }
            else
            {
               ccLayerName.Format("L%d", i);
                layIndex = Graph_Level(ccLayerName, "", 0);
            }

            // Get the padshape
            int padptr = get_padshape(shapeNum);
            if (padptr < 0)
            {
               CString tmp;
               tmp.Format("Bad padshape [%d] in padstack [%s]\n", shapeNum, padstack->padstackName);
			      fprintf(ferr, tmp);
               //Graph_Block_Off();
               //return -1;
               // We still need to process the remaining pads in the padstack.
            }
            else
            {
               // Insert the padshape to the padstack
               Graph_Block_Reference(padshapearray[padptr]->name, NULL, 0, 0.0, 0.0, 0.0, 0, 1.0, layIndex, TRUE);
               padstack->creatFlag = 1; // indicate that padstack content is defined under .pst command
            }
         }

         // Don't insert the same padshape twice on the same layer
         shapeNum = -1;
         if (lmpLayerName != "INNER")
         {
            if ((lp = tmpString.Tokenize(" \t\n", curPos)) != "")
                shapeNum = atoi(lp);
         }
      }
   }
   ulsCnt = 0;

   Graph_Block_Off();

   cur_state = STAT_UNKNOWN;

   return 1;
}

/******************************************************************************
* IsLpmLayerMapped
*/
static int IsLpmLayerMapped(CString layerName)
{
   for (int i = 0; i<llistcnt; i++)
   {
         DDELlist *ddeLayer = llistarray[i];
         if (ddeLayer->lpmname == layerName)
            return 1;
   }
   return 0;
}

/******************************************************************************
* GetPadstackName
*/
static int GetPadstackName(int padstackNum, CString &padstackName, BOOL isCompMirrored)
{
   if (padstackNum > -1)
   {
      // Look for the padstackName if there is a padstack number
      // and return the padstack name only if the padstack is defined in .pst
      for (int i=0; i<padstackCnt; i++)
      {
         DDEPadstack *padstack = padstackArray[i];
         if (padstack->padstackNum == padstackNum && padstack->creatFlag == 1)
         {
            padstackName = padstack->padstackName;
            return 1;
         }
      }
   }

   if (padstackName != "")
   {
      if (isCompMirrored)
         padstackName += "[m]";

      // If the padstack is already created, then return
      if (Graph_Block_Exists(doc, padstackName, -1))
         return 1;
   }
   else if (padstackName == "")
   {
      padstackName.Format("PAD_%d", padstackCnt);
   }

   // There is no padstack with such padstack name, so create it
   BlockStruct *block = Graph_Block_On(GBO_APPEND, padstackName, -1, 0);
   block->setBlockType(BLOCKTYPE_PADSTACK);

   double drillSize = 0.0;
   BOOL plated = FALSE;
   for (int i=0; i<MAX_LAYER; i++)
   {
      if (pinl[i].shapeindex < 0)
         continue;

      // Graph the layer
      CString ccLayerName;
      if (isCompMirrored) // Get mirrored layer
         ccLayerName.Format("L%d", llistarray[i]->mirrorindex);
      else
         ccLayerName.Format("L%d", i);

      int layIndex = Graph_Level(ccLayerName, "", 0);

      // Get the padshape
      int padptr = get_padshape(pinl[i].shapeindex);
      if ( padptr< 0)
      {
         CString tmp;
         tmp.Format("Bad padshape [%d] in padstack [%s]\n", pinl[i].shapeindex, padstackName);
			fprintf(ferr, tmp);
         //Graph_Block_Off();
         //return -1;
         // we should still process the remainder of the padshapes.
      }
      else
      {
         DDEPadshape *padShape = padshapearray[padptr];

         // Get the drill size if it is bigger
         if (padShape->drill > drillSize)
         {
            drillSize = padShape->drill;
            plated = padShape->plated;
         }

         // Insert the padshape to the padstack
         Graph_Block_Reference(padShape->name, NULL, 0, 0.0, 0.0, 0.0, 0, 1.0, layIndex, TRUE);
      }
   }

   if (drillSize > 0)
   {
      // Insert the drill if there is one
      int layIndex = Graph_Level("DRILLHOLE", "", 0);
      LayerStruct *layer;
      if (layer = doc->FindLayer(layIndex))
      {
         layer->setComment("Drill");
         layer->setLayerType(LAYTYPE_DRILL);
      }

      int drillIndex = get_drillindex(drillSize, plated);
      if (drillIndex > -1)
      {
         CString drillName;
         drillName.Format("DRILL_%d", drillIndex);
         Graph_Block_Reference(drillName, NULL, 0, 0.0, 0.0, 0.0, 0, 1.0, layIndex, TRUE);
      }
   }
   Graph_Block_Off();

   // Add to the padstackArray
   DDEPadstack *padstack = new DDEPadstack;
   padstackArray.SetAtGrow(padstackCnt++, padstack);
   padstack->padstackName = padstackName;
   padstack->padstackNum = -1;
   padstack->drillSize = drillSize;
   padstack->creatFlag = 2; // indicate that padstack content is defined under .wlp command

   return 1;
}

/******************************************************************************
* char *get_attribmap
*/
static const char *get_attribmap(const char *c)
{
   static CString tmp;

   for (int i=0; i<attribmapcnt; i++)
   {
      if (attribmaparray[i]->attrib.CompareNoCase(c) == 0)
         return attribmaparray[i]->mapattrib.GetBuffer(0);
   }

   tmp = c;
   tmp.MakeUpper();
   return tmp.GetBuffer(0);
}

/******************************************************************************
//* get_layertype
*/
//static int get_layertype(const char *l)
//{
//   for (int i=0; i<MAX_LAYTYPE; i++)
//   {
//      if (_STRICMP(layerTypeToString(i), l) == 0)
//         return i;
//   }
//
//   return   LAYTYPE_UNKNOWN; 
//}

/******************************************************************************
* load_iplsettings
*/
static int load_iplsettings(const CString fname)
{
   char  line[255];
   char  *lp;

   layer_attr_cnt = 0;
   ComponentSMDrule = 0;
   REFNAME_LAYER = -1;
   EXPLODE_BOARDKIND = TRUE;
   PADSTACKJOB = TRUE;
   PADSHAPE_PREFIX = "";
   AltComTxt = FALSE;
   HatchLineFill = FALSE;

   FILE *filePrt = fopen(fname, "rt");
   if (filePrt == NULL)
   {
      // no settings file found
      CString tmp;
      tmp.Format("File [%s] not found", fname);
      ErrorMessage(tmp, "DDE Settings", MB_OK | MB_ICONHAND);
      return 0;
   }
              
   while (fgets(line, 255, filePrt))
   {
      if ((lp = get_string(line, " \t\n")) == NULL)
         continue;

      if (lp[0] == '.')
      {
         if (!STRICMP(lp, ".EXPLODE_BOARDKIND"))
         {
            if ((lp = get_string(NULL, " \t\n")) == NULL)
               continue;
            if (lp[0] == 'n' || lp[0] == 'N')
               EXPLODE_BOARDKIND = FALSE;
         }
         else if (!STRICMP(lp, ".ALT_COM_TXT"))
         {
            if ((lp = get_string(NULL, " \t\n")) == NULL)
               continue;
            if (toupper(lp[0]) == 'Y')
               AltComTxt = TRUE;
         }
         else if (!STRICMP(lp, ".REFNAMELAYER"))
         {
            if ((lp = get_string(NULL, " \t\n")) == NULL)
               continue;
            REFNAME_LAYER = atoi(lp);
         }
         else if (!STRCMPI(lp, ".PadstackPolygon"))
         {
            if ((lp = get_string(NULL, " \t\n")) == NULL)
               continue;
            PADSTACK_POLYGON = lp;
            PADSTACK_POLYGON.TrimLeft();
            PADSTACK_POLYGON.TrimRight();
         }
         else if (!STRCMPI(lp, ".TrackPolygon"))
         {
            if ((lp = get_string(NULL, " \t\n")) == NULL)
               continue;
            TRACK_POLYGON = lp;
            TRACK_POLYGON.TrimLeft();
            TRACK_POLYGON.TrimRight();
         }
         else if (!STRCMPI(lp, ".ComponentSMDrule"))
         {
            if ((lp = get_string(NULL, " \t\n")) == NULL)
               continue;
            ComponentSMDrule = atoi(lp);
         }
         else if (!STRICMP(lp, ".ATTRIBMAP"))
         {
            if ((lp = get_string(NULL, " \t\n")) == NULL)
               continue;
            CString attrib = lp;
            attrib.MakeUpper();
            attrib.TrimLeft();
            attrib.TrimRight();

            if ((lp = get_string(NULL, " \t\n")) == NULL)
               continue;
            CString mapattrib = lp;
            mapattrib.MakeUpper();
            mapattrib.TrimLeft();
            mapattrib.TrimRight();

            DDEAttribmap *attribMap = new DDEAttribmap;
            attribmaparray.SetAtGrow(attribmapcnt++, attribMap);
            attribMap->attrib = attrib;
            attribMap->mapattrib = mapattrib;
            
         }
         else if (!STRICMP(lp, ".LAYERATTR"))
         {
            if ((lp = get_string(NULL, " \t\n")) == NULL)
               continue; 
            CString ddelayer = _strupr(lp);
            ddelayer.TrimLeft();
            ddelayer.TrimRight();

            if ((lp = get_string(NULL, " \t\n")) == NULL)
               continue; 
            CString cclayer = lp;
            cclayer.TrimLeft();
            cclayer.TrimRight();

            int laytype = stringToLayerTypeTag(cclayer);
            if (layer_attr_cnt < MAX_LAYER)
            {
               layer_attr[layer_attr_cnt].attr = laytype;
               layer_attr[layer_attr_cnt].name = ddelayer;
               layer_attr_cnt++;
            }
            else
            {
               fprintf(ferr, "Too many .LAYERATTR\n");
               display_error++;
            }
         }
         else if (!STRICMP(lp, ".PADSHAPE_PREFIX"))
         {
            if ((lp = get_string(NULL, " \t\n")) == NULL)
               continue; 
            PADSHAPE_PREFIX = lp;
         }
         else if (!STRICMP(lp, ".HATCHLINEFILL"))
         {
            if ((lp = get_string(NULL, " \t\n")) == NULL)
               continue;
            if (toupper(lp[0]) == 'Y')
               HatchLineFill = TRUE;
         }
      }
   }

   fclose(filePrt);
   return 1;
}

/******************************************************************************
* change_refnames
*/
static int change_refnames()
{
   if (EXPLODE_BOARDKIND)
   {
      for (int i=0; i<slistcnt; i++)
      {
         DDESlist *slist = slistarray[i];
         if ((slist->kind.CompareNoCase("BOARDKIND") && slist->kind.CompareNoCase("BOARD")))
            continue;
         if (!slist->pincnt)
            continue;

         // the Board Shape contains pins, it is recommended that 
         CString tmp;
         tmp.Format("The BoardShape [%s] contains pins. It is recommended NOT to explode this shape!\nDo you still want to explode this shape?", 
               slistarray[i]->name);
         if (ErrorMessage(tmp, "Explode BOARD Kind", MB_YESNO | MB_DEFBUTTON2)!=IDYES)
            EXPLODE_BOARDKIND = FALSE;
      }
   }

	int i=0;
   for (i=0; i<slistcnt; i++)
   {
      DDESlist *slist = slistarray[i];
      if (EXPLODE_BOARDKIND && (!slist->kind.CompareNoCase("BOARDKIND") || !slist->kind.CompareNoCase("BOARD")))
      {
         // kill the component from the list
         // explode comp
         for (int ii=0; ii<complistcnt; ii++)
         {
            DDEComp  *complist = complistarray[ii];
            if (complist->shapeindex != slist->index)
               continue;

            CString cname;
            cname.Format("%d", complist->compindex);
            DataStruct *data = datastruct_from_refdes(doc, file->getBlock(), cname);
            //if (data)
               //ExplodeInsert(doc, data, &(file->getBlock()->getDataList()));  // this also deletes the insert entity
            complist->exploded = true;
         }
      }
   }

   for (i=0; i<slistcnt; i++)
   {
      DDESlist *slist = slistarray[i];
      if (!slist->kind.CompareNoCase("FIDUCIAL"))
      {
         BlockStruct *block = Graph_Block_Exists(doc, slist->name, -1);
         if (block)
            block->setBlockType(BLOCKTYPE_FIDUCIAL);
      }
      else
      {
         BlockStruct *block = Graph_Block_Exists(doc, slist->name, -1);
         if (block)
         {
            if (slist->pincnt)
               block->setBlockType(BLOCKTYPE_PCBCOMPONENT);
            else
               block->setBlockType(BLOCKTYPE_GENERICCOMPONENT);
         }
      }
   }

   for (i=0; i<complistcnt; i++)
   {
      DDEComp *complist = complistarray[i];
      if (complist->exploded)
         continue;

      CString cname;
      cname.Format("%d", complist->compindex);
      DataStruct *data = datastruct_from_refdes(doc, file->getBlock(), cname);
      if (data)
      {
         BlockStruct *block = doc->Find_Block_by_Num(data->getInsert()->getBlockNumber());
         data->getInsert()->setRefname(STRDUP(complist->name));
         data->getInsert()->setInsertType(default_inserttype(block->getBlockType()));
         int sptr = get_slistptr(complist->shapeindex);

         DDESlist *slist = slistarray[sptr];
         CString typ = "";

         if (strlen(complist->device))
            typ = complist->device;
         else if (strlen(complist->value))
            typ = complist->value;
         else if (slist->pincnt)
            typ.Format("%s_%s", block->getName(), data->getInsert()->getRefname());
         else
            data->getInsert()->setInsertType(insertTypeUnknown);

         if (data->getInsert()->getInsertType() == INSERTTYPE_FIDUCIAL)
         {
            // do nothing
         }
         else if (slistarray[sptr]->pincnt == 0)
         {
            data->getInsert()->setInsertType(insertTypeMechanicalComponent);
            block->setBlockType(BLOCKTYPE_MECHCOMPONENT);
         }
         else if (complist->fiducial)
         {
            data->getInsert()->setInsertType(insertTypeFiducial);
            block->setBlockType(BLOCKTYPE_FIDUCIAL);
         }
         else if (complist->testpoint)
         {
            data->getInsert()->setInsertType(insertTypeTestPoint);
            block->setBlockType(BLOCKTYPE_TESTPOINT);
         }
         else if (EXPLODE_BOARDKIND && (complist->boardoutline))
         {
            data->getInsert()->setInsertType(insertTypeUnknown);
            block->setBlockType(BLOCKTYPE_UNKNOWN);
         }
         else if (strlen(typ))
         {
            data->getInsert()->setInsertType(insertTypePcbComponent);

            TypeStruct *newtype = AddType(file, typ);
            if (newtype->getBlockNumber() == -1)
               newtype->setBlockNumber( block->getBlockNumber());
            else if (newtype->getBlockNumber() != block->getBlockNumber())
            {
               typ.Format("%s_%s", block->getName(), data->getInsert()->getRefname());
               newtype = AddType(file, typ);
               newtype->setBlockNumber( block->getBlockNumber());
            }

            doc->SetUnknownAttrib(&data->getAttributesRef(), ATT_TYPELISTLINK, typ, SA_OVERWRITE, NULL); //  
         }

         if (strlen(complist->value))
            doc->SetUnknownAttrib(&data->getAttributesRef(), ATT_VALUE, complist->value, SA_OVERWRITE, NULL); //  
      }
      else
      {
         // this might not be here anymore, such as a boardkind etc..
      }
   }

   return 1;
}

/******************************************************************************
* clean_polys
*/
static void clean_polys(CDataList *DataList, double small_element)
{
   POSITION dataPos = DataList->GetHeadPosition();
   while (dataPos)
   {
      DataStruct *data = DataList->GetNext(dataPos);

      switch (data->getDataType())
      {
      case T_POLY:
         {
            POSITION polyPos = data->getPolyList()->GetHeadPosition();
            while (polyPos)
               CleanPoly(data->getPolyList()->GetNext(polyPos), small_element);
         }
         break;

      case T_INSERT:
         {
            BlockStruct *block = doc->Find_Block_by_Num(data->getInsert()->getBlockNumber());

            if (!(block->getFlags() & BL_TOOL || block->getFlags() & BL_APERTURE || block->getFlags() & BL_BLOCK_APERTURE))
               clean_polys(&block->getDataList(), small_element);
         }
         break;
      }
   }
}

/******************************************************************************
* get_drillindex
*/
static int get_drillindex(double size, BOOL plated = FALSE)
{
   if (size == 0)
      return -1;

   DDEDrill drill;
   for (int i=0; i<drillcnt; i++)
   {
      drill = drillarray.ElementAt(i);
      if (drill.d == size)
         return drill.toolindex;         
   }

   CString name;
   name.Format("DRILL_%d", drillcnt);
   Graph_Tool(name, 0, size, 0, 0, 0, 0L, plated);
   drillarray.SetAtGrow(drillcnt++, drill);  
   drill.d = size;
   drill.toolindex = drillcnt;

   return drillcnt-1;
}
 
/******************************************************************************
* go_ipl
*   Call function associated with next token.
*/
static int go_ipl(List *tok_lst,int lst_size)
{
   while (fgets(line, MAX_LINE, ifp) != NULL && ipl_file_end > 0)
   {
      linecnt++;

      if (strlen(line) && line[strlen(line)-1] == '\n')
         line[strlen(line)-1] = '\0';  // kill lineend
      CString tmplin = line;  // both MAX_LINE

      char *lp;
      if ((lp = strtok(line, " \t\n")) == NULL)  // no empty line
         continue;      
      if (lp[0] != '.')  // every command must start with a .
         continue;

      CpyStr(token, lp, MAX_LINE);

      int tokIndex = tok_search(tok_lst, lst_size);
      if (tokIndex >= 0)
         (*tok_lst[tokIndex].function)();
      else
         fprintf(ferr, "Unknown line at %ld ->%s\n", linecnt, tmplin);
   } 

   return 1;
}

/******************************************************************************
* tok_search
*   Search for the token in a command token list.
*/
static int tok_search(List *tok_lst,int tok_size)
{
   for ( int i=0; i<tok_size; ++i)
   {
      if (!STRNICMP(token,tok_lst[i].token,strlen(tok_lst[i].token)))
         return(i);
   }
   return(-1);
}

/******************************************************************************
* ipl_remark
*  .rem
*     blah, blah
*  .end
*/
static int ipl_remark()
{
   while (fgets(line, MAX_LINE, ifp))
   {
      linecnt++;
      
      if (strlen(line) && line[strlen(line)-1] == '\n')
         line[strlen(line)-1] = '\0';  // kill lineend.

      char *lp;
      if ((lp = strtok(line, " \t\n")) == NULL)  // no empty line
         continue;
      if (lp[0] != '.')  // every command must start with a .
         continue;
      if (!STRCMPI(lp, ".end"))
         break;
   }

   return 1;
}

/******************************************************************************
* ipl_dim
*/
static int ipl_dim()
{
	cur_state = STAT_DIM;

   // still can be part of .typ
   return 1;
}

/******************************************************************************
* ipl_dob
*/
static int ipl_dob()
{
   return 1;
}

/******************************************************************************
* ipl_die
*/
static int ipl_die()
{
   return 1;
}

/******************************************************************************
* x_ipl_dim
*  .dim D 30900 F0 80
*  .dob P 669500 552500 0 TH3-1
*  .dob A 688100 565000 50 bol-8
*  .die
*/
static int x_ipl_dim()
{
   while (fgets(line, MAX_LINE, ifp))
   {
      linecnt++;

      if (strlen(line) && line[strlen(line)-1] == '\n')
         line[strlen(line)-1] = '\0';  // kill lineend

      char *lp;
      if ((lp = strtok(line, " \t\n")) == NULL)  // no empty line
         continue;
      if (lp[0] != '.')  // every command must start with a
         continue;
      if (!STRCMPI(lp, ".die"))
         break;
   }

   return 1;
}

/******************************************************************************
* ipl_arc
*/
static int ipl_arc()
{
   char *lp;

   // do not write hatch traces
   if (cur_dfaon)
   {
      // do not do the trace-fills of the preceeding DFA was not filled.
      return 0;   //
   }

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double x = ipl_unit(atof(lp));

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double y = ipl_unit(atof(lp));

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   CString layername;
   layername.Format("L%d", atoi(lp));
   int lindex = Graph_Level(layername,"", 0);

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double r = ipl_unit(atof(lp));

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0; 
   double starta = atof(lp);   

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double enda = atof(lp);

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   CString tsh;
   tsh.Format("TSH%d", atoi(lp));

   int err;
   int widthcode = Graph_Aperture(tsh, T_ROUND, 0.0, 0.0, 0.0, 0.0, 0.0, 0, BL_WIDTH, 0, &err);

   switch (cur_state)
   {
   case STAT_SHAPE:
      Graph_Block_On(GBO_APPEND, cur_name, -1, 0);
      x = x - slistarray[slistcnt-1]->xref;
      y = y - slistarray[slistcnt-1]->yref;
      break;
   case STAT_BOARDOUTLINE:
      // these are the fill traces for an area.
      //goodoutline += 2; // make sure it is more than 1.
      //return OK;
      break;
   case STAT_AREA:
      // these are the fill traces for an area.
      //return OK;
      break;
   default:
      //
      break;
   }
/*
   if ((lp = get__layername(laynr, layername)) != NULL)
   {
      double delta = enda - starta;
      if (delta == 360)
         LG_Circle(0,inch_2_dbunitpoint2(x,y),0L,  
             lp,widthcode,inch_2_dbunit(r));
      else
         LG_Arc(0,inch_2_dbunitpoint2(x,y),0L,  
             lp,widthcode,inch_2_dbunit(r),degree_2_dbunit(starta),
             degree_2_dbunit(delta));
   }
*/

   double delta = enda - starta;
   if (fabs(delta) == 360)
      DataStruct *data = Graph_Circle(lindex, x, y, r, 0L, widthcode, 0, 0);
   else
      DataStruct *data = Graph_Arc(lindex, x, y, r, DegToRad(starta), DegToRad(delta), 0, widthcode, 0);

   if (cur_state == STAT_SHAPE)  
      Graph_Block_Off();

   return 1;
}

/******************************************************************************
* ipl_tra
* .tra track     : trackshapenum xstart ystart xend yend layer
*/
static int ipl_tra()
{
   char     *lp;

   // do not write hatch traces unless HatchLineFill is on
   if (cur_dfaon && HatchLineFill == FALSE)
   {
      // do not do the trace-fills of the preceeding DFA was not filled.
      //if (!get_fill_from_curdfa())
      return 0;   //
   }

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   CString tsh;
   tsh.Format("TSH%d", atoi(lp));

   int err;
   int widthcode = Graph_Aperture(tsh, T_ROUND, 0.0, 0.0, 0.0, 0.0, 0.0, 0, BL_WIDTH, 0, &err);

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double x1 = ipl_unit(atof(lp));

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double y1 = ipl_unit(atof(lp));

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double x2 = ipl_unit(atof(lp));

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double y2 = ipl_unit(atof(lp));

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   CString layername;
   layername.Format("L%d", atoi(lp));
   int lindex = Graph_Level(layername, "", 0);

   switch (cur_state)
   {
   case STAT_SHAPE:
      if (!cur_dfaon)
         Graph_Block_On(GBO_APPEND, cur_name, -1, 0);
      x1 = x1 - slistarray[slistcnt-1]->xref;
      y1 = y1 - slistarray[slistcnt-1]->yref;
      x2 = x2 - slistarray[slistcnt-1]->xref;
      y2 = y2 - slistarray[slistcnt-1]->yref;
      break;
   case STAT_BOARDOUTLINE:
      // these are the fill traces for an area.
      //goodoutline += 2; // make sure it is more than 1.
      //return OK;
      break;
   case STAT_AREA:
      // these are the fill traces for an area.
      //return OK;
      break;
   default:
      //
      break;
   }

   if (!cur_dfaon)
   {
		// If cur_state is NETLIST, we clearly have an Etch.
		// Case 1429, If cus_stat is unknown, i.e. not  specifically a board
		// outline, etc, then assume we have an Etch.

      DataStruct *data = Graph_PolyStruct(lindex, 0L, 0);

      if (cur_state == STAT_NETLIST || cur_state == STAT_UNKNOWN)
      {
			data->setGraphicClass(GR_CLASS_ETCH);

			// Set netname only if clearly processing a netlist
         if (strlen(cur_netname) && cur_state == STAT_NETLIST)
         {
            doc->SetUnknownAttrib(&data->getAttributesRef(), ATT_NETNAME, cur_netname, SA_OVERWRITE, NULL);
         }
      }
   }

   int filled = 0;
   int close = 0;
   CPoly *cp = Graph_Poly(NULL, widthcode, filled, 0, close);

   if (cur_dfaon)
	{
      cp->setHatchLine(true);
		cur_dfa_has_traces = true;
	}

   Graph_Vertex(x1, y1, 0.0);
   Graph_Vertex(x2, y2, 0.0);

   if (!cur_dfaon && cur_state == STAT_SHAPE)   
      Graph_Block_Off();

   return 1;
}

/******************************************************************************
* *clean_typ
*/
static char *clean_typ(char *typ)
{
   if (typ == NULL)
      return NULL;
   if (strlen(typ) < 3)
      return typ;

   if (typ[0] == '\'')
   {
      ++typ;
      typ[strlen(typ)-1] = '\0';
   }
   else if (typ[0] == '"')
   {
      ++typ;
      typ[strlen(typ)-1] = '\0';
   }

   return typ;
}

/******************************************************************************
* ipl_typ
* .typ type      : xref yref xmax ymax typenumber typename
*/
static int ipl_typ()
{
   char *lp;
   int cnt = 0;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double xref = ipl_unit(atof(lp));
    
   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double yref = ipl_unit(atof(lp)); 

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double xmax = ipl_unit(atof(lp));

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double ymax = ipl_unit(atof(lp));

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   int typnr = atoi(lp);

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   cur_name = clean_typ(lp);
   
   // open file for writting
   char drive[_MAX_DRIVE];
   char dir[_MAX_DIR];
   char fname[_MAX_FNAME];
   char ext[_MAX_EXT];
   _splitpath( cur_name, drive, dir, fname, ext );  // need to do this, because panel only knows the path.ext
	char typname[_MAX_FNAME + _MAX_EXT];
	strcpy(typname, fname);
	strcat(typname, ext);
   BlockStruct *block = Graph_Block_Exists(doc, typname, -1);

   // here check if we can only use the component shape name and not need the complete path.
   // but if this is already used, try the big one.
   if (block == NULL)
      cur_name = typname;

   if (block = Graph_Block_Exists(doc, cur_name, -1))
   {
      fprintf(ferr, "Shape [%s] already defined.\n", cur_name);
      display_error++;

      CString tmp;
      while (block)
      {
         tmp.Format("%s_%d", cur_name, ++cnt);
         block = Graph_Block_Exists(doc, tmp, -1);
      }
      cur_name = tmp;
   }

   DDESlist *slist = new DDESlist;
   slistarray.SetAtGrow(slistcnt++, slist);  
   slist->kind = "";
   slist->name = cur_name;
   slist->originalname = lp;
   slist->index = typnr;
   slist->pincnt = 0;
   slist->xref  = xref;
   slist->yref  = yref;
   slist->master = TRUE;

   cur_state = STAT_SHAPE;

   return 1;
}

/******************************************************************************
* ipl_com
* .com component : compnum x y dir lay mir/not fix/visi stat tnum typename
*
* the component is always followed by 3 or more .txt entries.
*/
static int ipl_com()
{
   char *lp;

   cur_state = STAT_COMPONENT;

   DDEComp *comp = new DDEComp;
   complistarray.SetAtGrow(complistcnt++, comp);
	comp->name = "";
	comp->device = "";
	comp->value = "";
	comp->x = 0.0;
	comp->y = 0.0;
	comp->mir = false;
	comp->written = false;
	comp->fiducial = false;
	comp->testpoint = false;
	comp->boardoutline = false;
   comp->exploded = false;
   comp->bottom = false;
	comp->rot = 0.0;
	comp->master = 0;
	comp->lay = 0;
	comp->shapeindex = 0;
	comp->compindex = 0;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
	int compnr = atoi(lp);
   comp->compindex = atoi(lp);
   CString compname = lp;  // this gets later changed to the true name

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   comp->x = ipl_unit(atof(lp));

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   comp->y = ipl_unit(atof(lp));

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;

   comp->rot = conv_rotation(lp);

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   int laynr = atoi(lp);

   if ((lp = strtok(NULL," \t\n")) == NULL) return 0;
   if (lp[0] == 'm')
      comp->mir = true;

   if (llistarray[laynr]->solder)
   {
      if (lp[0] != 'm')
      {
         fprintf(ferr, "Component Nr [%d] placed on BOTTOM layer but not mirrored ?\n", comp->compindex);
         display_error++;
      }
      comp->bottom = true;
   }
   else
   {
      if (lp[0] == 'm')
      {
         fprintf(ferr, "Component Nr [%d] placed on TOP layer but MIRRORED ?\n", comp->compindex);
         display_error++;
      }
      comp->bottom = false;
   }

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0; // fix
   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0; // stat
   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0; // tnum
   comp->shapeindex = atoi(lp);

   int sptr = get_slistptr(comp->shapeindex);
   comp->master = slistarray[sptr]->master;
   slistarray[sptr]->master = FALSE;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;

   cur_data = Graph_Block_Reference(slistarray[sptr]->name, compname, 0, comp->x, comp->y, DegToRad(comp->rot),
         comp->mir, 1.0, -1, TRUE);

   if (comp->bottom)
      cur_data->getInsert()->setPlacedBottom(true);

   return 1;
}

/******************************************************************************
* ipl_unit
*   ipl to inch and round to 1/10 mil
*/
double ipl_unit(double x)
{
   double y = x * Units_Factor(UNIT_MILS, pageunits) / 100; 
   return y;
}

/******************************************************************************
* ipl_end
*/
static int ipl_end()
{
   // this is not for .rem statement, only the end of file.
   ipl_file_end--;
   return 1;
}

/******************************************************************************
* get_slistptr
*/
int get_slistptr(int s)
{
   for (int i=0; i<slistcnt; i++)
   {
      if (slistarray[i]->index == s)
         return i;
   }

   fprintf(ferr, "Shape index [%d] not found in Slist at %ld\n", s, linecnt);
   display_error++;

   return -1;
}

/******************************************************************************
* conv_rotation
*   return 0 to 359.999 degree.
*/
double conv_rotation(char *lp)
{
   double rot = 0;
   if (!strchr(lp, 'a'))
   {
      rot = 90 * atoi(lp);
      return rot;
   }

   CString tmp1 = "";
   CString tmp2 = "";
   BOOL aFound = FALSE;
   for (int i=0; i<(int)strlen(lp); i++)
   {
      if (lp[i] == 'a')
      {
         aFound = TRUE;
         continue;
      }

      if (aFound)
         tmp2 += lp[i];
      else
         tmp1 += lp[i];
   }
   rot = 90 * atof(tmp1) + atof(tmp2);

/* 
   char tmp[80];
   int tmpcnt = 0;
   for (int i=0; i<(int)strlen(lp); i++)
   {
      if (lp[i] == 'a')
         break;
      tmp[tmpcnt] = lp[i];
      tmpcnt++;
   }
   tmp[tmpcnt] = '\0';
   rot = 90 * atoi(tmp);


   tmpcnt = 0
   for (i=0; i<(int)strlen(lp); i++)
   {
      if (lp[i] == 'a')
         continue;
      tmp[tmpcnt] = lp[i];
      tmpcnt++;
   }
   tmp[tmpcnt] = '\0';
   rot += atoi(tmp);
 */

   while (rot < 0)
      rot += 360;   
   while (rot >= 360)
      rot -= 360;   

   return rot;
}

/******************************************************************************
* ipl_txt
* .txt text      : textx texty layer tdir tmir options tsize trackshapenum text
*/
static int ipl_txt()
{
   char     *lp;
   int         special_prop = 0;
   
   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double x = ipl_unit(atof(lp));

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double y = ipl_unit(atof(lp));

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   int laynr = atoi(lp);
   CString  layername;
   layername.Format("L%d", laynr);
   int lindex = Graph_Level(layername, "", 0);

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double ori = 90*atoi(lp);

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   int mirror = atoi(lp);

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0; // justification

   DbFlag flg = 0;
   if (strlen(lp) >= 2)
   {
      if (lp[0] == 'L')
         flg |= GRTEXT_W_L;
      else if (lp[0] == 'C')
         flg |= GRTEXT_W_C;
      else if (lp[0] == 'R')
         flg |= GRTEXT_W_R;

      if (lp[1] == 'B')
         flg |= GRTEXT_H_B;
      else if (lp[1] == 'C')
         flg |= GRTEXT_H_C;
      else if (lp[1] == 'T')
         flg |= GRTEXT_H_T;
   }

   int ta=0; //textAlignment
   int la=0; // lineAlignment
   if (strlen(lp) >= 2)
   {
      if (lp[0] == 'L')
         ta = 0;
      else if (lp[0] == 'C')
         ta = 1;
      else if (lp[0] == 'R')
         ta = 2;

      if (lp[1] == 'B')
         la = 0;
      else if (lp[1] == 'C')
         la = 1;
      else if (lp[1] == 'T')
         la = 2;
   }

   int visible = TRUE;
   if (strchr(lp, 'i'))
      visible = FALSE;
   
   if (strchr(lp, 'a'))
   {
      lp++; // advance justification
      lp++;
      ori += conv_rotation(lp);
   }
           
   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double height = ipl_unit(atof(lp));

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   int widthcode = atoi(lp);

   if ((lp = strtok(NULL, "\n")) == NULL)
      return 0;
   CString prosa = lp;
   prosa.TrimLeft();
   prosa.TrimRight();
   if (prosa.Left(1) == '\'')
      prosa.Delete(0,1);
   if (prosa.Right(1) == '\'')
      prosa.Delete(strlen(prosa)-1,1);

   // there are text fields on DFA areas.
   if (cur_dfaon) 
   {
      if (cur_dfadata && strlen(prosa))
         doc->SetUnknownAttrib(&cur_dfadata->getAttributesRef(), ATT_NAME, prosa, SA_OVERWRITE, NULL); //  
      return 0;
   }

   while (ori < 0)                
      ori += 360;
   while (ori >= 360)                
      ori -= 360;

   switch (cur_state)
   {
      case STAT_SHAPE:
         // do not change SCLG_XXX
         Graph_Block_On(GBO_APPEND, cur_name, -1, 0);
         x  = x - slistarray[slistcnt-1]->xref;
         y  = y - slistarray[slistcnt-1]->yref;
         break;
      case STAT_COMPONENT:
         // these are component values
         // here check layers against .sys
         switch (layer_type(laynr, mirror))
         {
            case  LAY_COMPNAME:
               complistarray[complistcnt-1]->name = prosa;
               special_prop = LAY_COMPNAME;
               cur_name = prosa;          // needed for .cop attribute.
               break;
            case  LAY_DEVICE:
               complistarray[complistcnt-1]->value = prosa;
               special_prop = LAY_DEVICE;
               break;
            case  LAY_ARTICLE:
               complistarray[complistcnt-1]->device = prosa;
               special_prop = LAY_ARTICLE;
               break;
         }
         break;
      default:
         break;
   }

   if (cur_state == STAT_COMPONENT)
   {
      DDELlist *layerlist = llistarray[laynr];
      DDEComp  *complist = complistarray[complistcnt-1];
      char special_prop_kwd[3][8] = {"REFNAME", "VALUE", "DEVICE"};

      // the .sys compnamelays 11,21,13,23 may contain multiple layers
      int lay = laynr;
      if (complist->bottom)
         lay = layerlist->mirrorindex;

      CString key;
      key.Format("%s", layerlist->name);

      if (lay == REFNAME_LAYER)  
      {
         key = ATT_REFNAME;
      }
      else if (special_prop)
      {
         key = special_prop_kwd[special_prop-1];
      }

      //ori = ori-complistarray[complistcnt-1]->rot;
      // normalize
      double x1 = 0;
      double y1 = 0;
      normalize_text(&x1, &y1, flg, ori, mirror, height, height * strlen(prosa) * TEXT_RATIO);

      x += x1;
      y += y1;

      double refnamex;
      double refnamey;
      double refx = x - complist->x;
      double refy = y - complist->y;
      double refnamerot = ori - complist->rot;
      Rotate(refx, refy, 360.0 - complist->rot, &refnamex, &refnamey);

      if (complist->mir)   
      {
         refnamex = -refnamex;

         int mirLaynr = layerlist->mirrorindex;
         CString mirLayerName;
         mirLayerName.Format("L%d", mirLaynr);
         lindex = Graph_Level(mirLayerName, "", 0);
      }

      if ((AltComTxt == FALSE) || (special_prop > 0))
      {
         Attrib *a = is_attvalue(doc, cur_data->getAttributesRef(), key, 1);
         if (a != NULL) // Here we need to check if this Comp has "Keyword" already
         {
            int i;
            CString tmp_key = key;
            for (i=1;i<100;i++)
            {
               key = tmp_key;
               key.Format("%s%d",tmp_key,i);
               a = is_attvalue(doc, cur_data->getAttributesRef(), key, 1); // Here we need to check if this Comp has "Keyword" already
               if (a == NULL)
                  break;
            }
         }
         // add "Keyword" this comp does not already have.
         if (strlen(prosa))
         {
            doc->SetUnknownVisAttrib(&cur_data->getAttributesRef(), get_attribmap(key), prosa, refnamex, refnamey, 
                  DegToRad(refnamerot), height, height * TEXT_RATIO, 0, 0, visible, SA_OVERWRITE, 0L , lindex, 0, 0, 0); 
         }
      }

      if (AltComTxt == TRUE)
      {
         // Get the Geometry used by current comp
         BlockStruct *block = doc->Find_Block_by_Num(cur_data->getInsert()->getBlockNumber());
         // Check if we are on new component, if geometry level ipl_com_txt attrib value != cur_comp then break
         Attrib *a = is_attvalue(doc, block->getAttributesRef() , "ipl_com_txt", 1);
         if (a == NULL) //first instance of Geom, add attrib ipl_com_txt with val of cur_name
            doc->SetUnknownAttrib(&block->getAttributesRef(), get_attribmap("ipl_com_txt"), cur_name, SA_OVERWRITE, &a);
         else
         {
            CString v = get_attvalue_string(doc, a);
            if (STRICMP(v, cur_name)!=0) // attrib found but not for current comp
               return 0;
         }

         if (special_prop > 0)
         {
            key = special_prop_kwd[special_prop-1];
            Attrib *a = is_attvalue(doc, block->getAttributesRef() , key, 1);
            if (a == NULL)
               doc->SetUnknownVisAttrib(&block->getAttributesRef(), get_attribmap(key), "", refnamex, refnamey, 
                  DegToRad(refnamerot), height, height * TEXT_RATIO, 0, 0, visible, SA_OVERWRITE, 0L , lindex, 0, 0, 0);
         }
         else
         {
            Graph_Block_On(GBO_APPEND, block->getName(), -1, 0);
            if (visible && strlen(prosa))
               Graph_Text(lindex, prosa, refnamex, refnamey, height, height * TEXT_RATIO, DegToRad(refnamerot), 0, TRUE, 0, 0, FALSE, -1, 0);
            Graph_Block_Off();
         }
      }
   } 
   else
   {
      // normalize
      double x1 = 0;
      double y1 = 0;
      //normalize_text( &x1, &y1, flg, ori, mirror, height, height * strlen(prosa) * TEXT_RATIO);

      x += x1;
      y += y1;
      if (visible && strlen(prosa))
         Graph_Text(lindex, prosa, x, y, height, height * TEXT_RATIO, DegToRad(ori), 0, TRUE, mirror, 0, FALSE, -1, 0, ta, la);
         //Graph_Text(lindex, prosa, x, y, height, height * TEXT_RATIO, DegToRad(ori), 0, TRUE, mirror, 0, FALSE, -1, 0);
   }

   if (cur_state == STAT_SHAPE)
      Graph_Block_Off();

   return 1;
}

/******************************************************************************
* ipl_lay
* .lay layattrib.: lay obstruction electric protection layname
*/
static int ipl_lay()
{
   char     *lp;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   int laynr = atoi(lp);

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   CString lprop = lp;
   lprop.MakeUpper();

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   CString lname = lp;

   CString lpmname = "";
   BOOL bottom = FALSE;
   if ((lp = strtok(NULL, " \t\n")) != NULL)
   {
      if (lp[0] == '\'')
      {
         if ((lp = strtok(NULL, "'")) == NULL)
            return 0;
      }     

      lpmname = lp;
      lpmname.Trim();
      for (int i=0; i<lpmcnt; i++)
      {
         DDELpm *lpm = lpmarray[i];
         if (!lpm->name.CompareNoCase(lpmname))
         {
            bottom = lpm->isBottomLayer;
            break;
         }
      }
   }

   if (laynr < MAX_LAYER)
   {
     DDELlist *layerlist = llistarray[laynr];
      layerlist->defined = TRUE;
      layerlist->name = lname;
      layerlist->lpmname = lpmname;
      layerlist->index = laynr;
      layerlist->isBottomLayer = bottom;
   
      int ltype = LAYTYPE_UNKNOWN;     
      if (laynr == 255)
         ltype = LAYTYPE_PAD_ALL;      

      for (int i=0; i<(int)strlen(lprop); i++)
      {
         if (lprop[i] == 'E' && laynr != 255)   // layer 255 is a special case because it is type PAD_ALL
         {
            layerlist->electrical = 1;
            if (laynr == 0)   
               ltype = LAYTYPE_SIGNAL_TOP;      
            else if (laynr == 1) 
               ltype = LAYTYPE_SIGNAL_BOT;      
            else
               ltype = LAYTYPE_SIGNAL_INNER;    
         }
         if (lprop[i] == 'P')
         {
            layerlist->plane = 1;
            ltype = LAYTYPE_POWERNEG;     
         }
         if (lprop[i] == 'S')
         {
            layerlist->solder = 1;
            ltype = LAYTYPE_SIGNAL_BOT;      

            if (lpmcnt == 0 && !bottom)   // There is no .lpm to specify if the layer is top or bottom placement, then use this to set it
               layerlist->isBottomLayer = TRUE;
         }
         if (lprop[i] == 'C')
         {
            layerlist->comp = 1;
            ltype = LAYTYPE_SIGNAL_TOP;      
         }
         if (lprop[i] == 'I')
         {
            layerlist->inner = 1;
            ltype = LAYTYPE_SIGNAL_INNER;    
         }
      }

      CString lnr;
      lnr.Format("L%d", laynr);
      int lindex = Graph_Level(lnr, "", 0);
      LayerStruct *layer = doc->FindLayer(lindex);
      layer->setComment(lname);
      layer->setLayerType(ltype);
   }
   else
   {
      fprintf(ferr, "Illegal Layer index [%d] at %ld\n", laynr, linecnt);
      display_error++;
   }

   if (laynr == 0)   // only give message on the first layer
   {
      if (lpmcnt == 0)
      {
/*
A padstackjob MUST have some .lpm lines to define polygons to laytype mapping.

If these lines are not present, it can't be a stack job.

These lines ALWAYS appears BEFORE the .lay -lines so if you haven't read at least one .lpm line before you encounter a  .lay -line
you can output an error saying something like: " Only design using padstacks can be translated. This design uses shapes" -or whatever you feel is appropriate.
*/
         ErrorMessage("Only design using padstacks can be translated. This design uses shapes!" ,"Unsupported Design Mode");

         fprintf(ferr, "\nOnly design using padstacks can be translated. This design uses shapes!\n");
         fprintf(ferr, "This means that padstacks can only extist on a single layer 0,1,255 and not on multiple layers.\n");
         fprintf(ferr, "Soldermask, paste etc... layers are not assigned to pads\n");
         fprintf(ferr, "No buried, blind via are allowed.\n\n");
         display_error++;
         PADSTACKJOB = FALSE;
      }
   }
   
   return 1;
}

/******************************************************************************
* layer_type
*   here need to make sure, that a mirrored layer also has the same type
*   as the unmirrored.
*/
static int layer_type(int laynr, int mirror)
{
   int lay = laynr;

#ifdef _DEBUG
DDELlist *ll = llistarray[lay];
#endif

   if (mirror)
      lay = llistarray[laynr]->mirrorindex;

   return llistarray[laynr]->layer_type;
}

/******************************************************************************
* ipl_sys
*/
static int ipl_sys()
{
   char  *lp;
   int l_type = 0;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;

   if (!STRCMPI(lp, "savegrpwise"))
   {
      if ((lp = strtok(NULL, " \t\n")) == NULL)
         return 1;
      if (lp[0] == 'y' || lp[0] == 'Y')
         savegrpwise = TRUE;
   }

   if (!STRCMPI(lp, "FastSave"))
   {
      if ((lp = strtok(NULL, " \t\n")) == NULL)
         return 1;
      if (lp[0] == 'n' || lp[0] == 'N')
         fastsave = FALSE;
   }

   if (!STRCMPI(lp, "compnamelays"))
      l_type = LAY_COMPNAME;

   if (!STRCMPI(lp, "devicelay"))
      l_type = LAY_DEVICE;

   if (!STRCMPI(lp, "articlelay"))
      l_type = LAY_ARTICLE;

   if (l_type == 0)
      return 1;
   
   while ((lp = strtok(NULL, ",")))
   {
      int l = atoi(lp);
      if (l >= 0 && l < MAX_LAYER)
         llistarray[l]->layer_type = l_type;
   }
   return 1;
}

/******************************************************************************
* ipl_tsh
*/
static int ipl_tsh()
{
   char *lp;
   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   cur_trackcode = atoi(lp);

   cur_state = STAT_TRACKCODE;

   return 1;
}

/******************************************************************************
* ipl_poe
*  .poe pol end   : end polygon name
*
*  .dfa eha 91 6 45c 3000 []
*  .poe border
*/
static int ipl_poe()
{
   char  *lp;

   if (graphcnt == 0)   
   {
      cur_dfaon = FALSE; // write buondary traces
      return 0;
   }
   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;

   // makes only a stop in the 
   if (!STRCMPI(lp, "borderpart"))
   {
      int start = 0;
      for (int i=0; i<graphcnt; i++)
      {
         DDEGraph tmpGraph = grapharray[i];
         if (tmpGraph.borderpart)
            start = i + 1;
      }

      DDEGraph graph1 = grapharray[graphcnt-1];
      if (graph1.typ != GRAPH_CIR)
      {
         DDEGraph graph2 = grapharray[start];
         if ((fabs(graph2.x - graph1.x) > SMALLNUMBER || fabs(graph2.y - graph1.y) > SMALLNUMBER) &&
             graph2.typ != GRAPH_CEN)  // graph_cen already treated special in write_graph
         {
            graph2.typ = GRAPH_COO;
            grapharray.SetAtGrow(graphcnt++, graph2);  
         }
      }
      grapharray[graphcnt-1].borderpart = TRUE;
      return 1;
   }

   int start = 0;
   for (int i=0; i<graphcnt; i++)
   {
      DDEGraph tmpGraph = grapharray[i];
      if (tmpGraph.borderpart)   
         start = i + 1;
   }

   // close last one !
   DDEGraph graph1 = grapharray[graphcnt-1];
   if (graph1.typ != GRAPH_CIR)
   {
      DDEGraph graph2 = grapharray[start];
      if ((fabs(graph2.x - graph1.x) > SMALLNUMBER || fabs(graph2.y - graph1.y) > SMALLNUMBER) &&
          graph2.typ != GRAPH_CEN)  // graph_cen already treated special in write_graph
      {
         graph2.typ = GRAPH_COO;
         grapharray.SetAtGrow(graphcnt++, graph2);  
      }
   }

   if (!STRCMPI(lp, "end"))
      lp = strtok(NULL, " \t\n");

   switch (cur_state)
   {
   case STAT_PADSHAPE:
      if (!STRCMPI(lp, PADSTACK_POLYGON))
      {
         write_padgraph(cur_name);
      }
      break;

   case STAT_TRACKCODE:
      if (!STRCMPI(lp, TRACK_POLYGON))
      {
         CString tsh;
         tsh.Format("TSH%d", cur_trackcode);
         if (graphcnt != 1)
         {
            fprintf(ferr, "Trackcode [%d] graphic not supported\n", cur_trackcode);
            display_error++;
         }
         else
         {
            if (grapharray[0].typ != GRAPH_CIR)
            {
               fprintf(ferr, "Trackcode [%d] graphic not supported\n", cur_trackcode);
               display_error++;
            }
            else
            {
               int err;
               Graph_Aperture(tsh, T_ROUND, grapharray[0].x * 2, 0.0, 0.0, 0.0, 0.0, 0, BL_WIDTH, 0, &err);
            }
         }
      }
      break;

   default:
      write_graph();
      break;
   }

   graphcnt = 0;

   return 1;
}

/******************************************************************************
* ipl_cir
* .cir circle    : radius
*/
static int ipl_cir()
{
   char *lp;

   if ((lp = strtok(NULL," \t\n")) == NULL)
      return 0;
   double radius = ipl_unit(atof(lp));

   DDEGraph graph;
   graph.x = radius;
   graph.borderpart = 0;
   graph.typ = GRAPH_CIR;
   grapharray.SetAtGrow(graphcnt++, graph);  

   return 1;
}

/******************************************************************************
* ipl_dfa
* .dfa def area  : kind lay shape dir spacing groupname
*/
static int ipl_dfa()
{
   char     *lp;

   if (cur_dfaon && cur_state == STAT_SHAPE) 
   {
      fprintf(ferr, "Syntax Error: .dfa started without ending .ena at %ld\n", linecnt);
      display_error++;
      Graph_Block_Off();
   }

   cur_dfaon = TRUE;
	cur_dfa_has_traces = false;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0; // kind
   cur_dfatyp = lp;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0; // lay
   CString  layername;
   layername.Format("L%d", atoi(lp));
   int lindex = Graph_Level(layername, "", 0);

   if ((lp = strtok(NULL," \t\n")) == NULL)
      return 0; // shape
   cur_trackcode = atoi(lp);

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0; // dir
   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0; // spacing
   if ((lp = strtok(NULL, " '\t\n")) == NULL)
      return 0; // groupname
   CString cur_dfaname = lp;

   CString netname = "";
   // groupname * [] '' are for all or none, other names are netnames
   if (!cur_dfaname.CompareNoCase("*"))
   {
      // all groups
   }
   else if (!cur_dfaname.CompareNoCase("[]"))
   {
      // no groups, but pour around
   }
   else if (!cur_dfaname.CompareNoCase("''"))
   {
      // no groups, but pour over
   }
   else
   {
      netname = cur_dfaname;
   }

   switch (cur_state)
   {
   case STAT_SHAPE:
      // do not change SCLG_XXX
      Graph_Block_On(GBO_APPEND, cur_name, -1, 0);
      cur_offset_x = slistarray[slistcnt-1]->xref;
      cur_offset_y = slistarray[slistcnt-1]->yref;
      break;
   case STAT_COMPONENT:
      break;
   default:
      // check if * or [] as name
      break;
   }

   cur_dfadata = Graph_PolyStruct(lindex, 0L, 0);

   if (strlen(netname))
      doc->SetUnknownAttrib(&cur_dfadata->getAttributesRef(), ATT_NETNAME, netname, SA_OVERWRITE, NULL); //  

   // (ha/ch/vko/tko/cko/cki)
   if (!cur_dfatyp.CompareNoCase("miller"))
   {
      cur_dfadata->setGraphicClass(GR_CLASS_BOARDOUTLINE);
      LayerStruct *layer = doc->FindLayer(lindex);
      layer->setComment("miller");
      layer->setLayerType(LAYTYPE_BOARD_OUTLINE);
   }
   else if (!cur_dfatyp.CompareNoCase("cmpsize"))
      cur_dfadata->setGraphicClass(GR_CLASS_COMPONENT_BOUNDARY);
   else if (!cur_dfatyp.CompareNoCase("vko"))
      cur_dfadata->setGraphicClass(GR_CLASS_VIAKEEPOUT);
   else if (!cur_dfatyp.CompareNoCase("vki"))
      cur_dfadata->setGraphicClass(GR_CLASS_VIAKEEPIN);
   else if (!cur_dfatyp.CompareNoCase("tko"))
      cur_dfadata->setGraphicClass(GR_CLASS_ROUTKEEPOUT);
   else if (!cur_dfatyp.CompareNoCase("tki"))
      cur_dfadata->setGraphicClass(GR_CLASS_ROUTKEEPIN);
   else if (!cur_dfatyp.CompareNoCase("cko"))
      cur_dfadata->setGraphicClass(GR_CLASS_PLACEKEEPOUT);
   else if (!cur_dfatyp.CompareNoCase("cki"))
      cur_dfadata->setGraphicClass(GR_CLASS_PLACEKEEPIN);
   else
   {
      //fprintf(ferr,"Unknown DFA kind [%s] at %ld\n", cur_dfatyp, linecnt);
      //display_error++;
   }

   return 1;
}

/******************************************************************************
* ipl_ena
*/
static int ipl_ena()
{
	// Case 1814, if processing a .dfa then and it contains traces (.tra) then make
	// the boundary hidden. The traces provide the visible graphic.
	if (cur_dfaon && cur_dfa_has_traces && cur_dfadata != NULL)
	{
		POSITION polyPos = cur_dfadata->getPolyList()->GetHeadPosition();
      while (polyPos != NULL)
      {
			CPoly *poly = cur_dfadata->getPolyList()->GetNext(polyPos);
			if (poly != NULL && poly->isFloodBoundary())
			{
				poly->setHidden(TRUE);
			}
		}
	}

   cur_dfaon = FALSE;
   cur_dfatyp = "";
   cur_dfadata = NULL;
   cur_offset_x = 0;
   cur_offset_y = 0;

   if (!cur_dfaon && cur_state == STAT_SHAPE)
      Graph_Block_Off();

   return 1;
}

/******************************************************************************
* get_fill_from_curdfa
*/
static int get_fill_from_curdfa()
{
   if (cur_dfaon && strlen(cur_dfatyp))
   {
      if (!cur_dfatyp.CompareNoCase("ha") ||
          !cur_dfatyp.CompareNoCase("oha")||
          !cur_dfatyp.CompareNoCase("ohh")||
          !cur_dfatyp.CompareNoCase("ohx")||
          !cur_dfatyp.CompareNoCase("pha")||
          !cur_dfatyp.CompareNoCase("eha")||
          !cur_dfatyp.CompareNoCase("etch")) // hatch 
       return TRUE;
   }
   return FALSE;
}

/******************************************************************************
* is_drowned
*/
static int is_drowned()
{
   if (cur_dfaon && strlen(cur_dfatyp))
   {
      if (!cur_dfatyp.CompareNoCase("ha") ||
          !cur_dfatyp.CompareNoCase("oha")||
          !cur_dfatyp.CompareNoCase("ohh")||
          !cur_dfatyp.CompareNoCase("ohx")||
          !cur_dfatyp.CompareNoCase("pha")||
          !cur_dfatyp.CompareNoCase("eha"))
       return TRUE;
   }

   return FALSE;
}

/****************************************************************************
* write_graph
*  This is a circle.
*  To make an area that are just a plain circle, we give it the center (.cen)
*  and a point at the perimeter of the circle. It can't be just any point on
*  the perimeter it must be a straight radius from the center so as you see in
*  this case, the .cen and the .coo share the same Y-coordinate.
*  -I believe we alternatively can  share the same X-coordinate.
*  Examples:
*  A circle placed at center 1inch,1inch diameter 1inch. Radius point is to the
*  left of the circle
*  .cen 100000 100000 0
*  .coo 50000 100000
*
*  Same circle described but here the radius point is to the right of the
*  center
*  .cen 100000 100000 0
*  .coo 150000 100000
*
*  Same circle described but here the radius point is above the center
*  .cen 100000 100000 0
*  .coo 100000 150000
*
*  Same circle described but here the radius point is below the center
*  .cen 100000 100000 0
*  .coo 100000 150000
*
*  All these variants are legal descriptions of a full circle.
*
*
*  > .dfa pha 3 11 0ce0 1000 *
*  > .cen 546000 375000 0
*  > .coo 549500 375000
*  > .poe border
*/
static int write_graph()
{
   if (graphcnt == 0)
      return 1;

   CString tsh;
   tsh.Format("TSH%d", cur_trackcode);

   int err;
   int widthcode = Graph_Aperture(tsh, T_ROUND, 0.0 , 0.0, 0.0, 0.0, 0.0, 0, BL_WIDTH, 0, &err);

   int close = TRUE;
   int newpoly = TRUE;
   int filled = get_fill_from_curdfa();
   CPnt *lastvertex = NULL;

	if (!cur_dfaon)
      DataStruct *data = Graph_PolyStruct( Graph_Level("0", 0, 1) , 0L, 0);
	else if (cur_dfadata)
		 cur_dfadata->setGraphicClass(GR_CLASS_ETCH);

   for (int i=0;i<graphcnt;i++)
   {
      DDEGraph curGraph = grapharray[i];
      if (newpoly)
      {
         CPoly *poly = Graph_Poly(NULL, widthcode, filled, 0, close);
         if (is_drowned())
         {
            if ( i > 0)
            {
               poly->setVoid(true);
               poly->setFilled(false);
            }
            else
            {
               poly->setFloodBoundary(true);
               poly->setFilled(false);
            }
         }
      }

      switch(curGraph.typ)
      {
      case GRAPH_CIR:
         {
         // x is radius
         Graph_Vertex( -curGraph.x - cur_offset_x, -cur_offset_y, 1);
         Graph_Vertex( curGraph.x - cur_offset_x, -cur_offset_y, 1);
         Graph_Vertex( -curGraph.x - cur_offset_x, -cur_offset_y, 0);
         }
         break;

      case GRAPH_COO:
         lastvertex = Graph_Vertex( grapharray[i].x-cur_offset_x, grapharray[i].y-cur_offset_y, 0);
         break;

      case GRAPH_CEN:
         {
            if (lastvertex && !newpoly)
            {
               DDEGraph graph1 = grapharray[i-1];
               DDEGraph graph2 = grapharray[i+1];
               if (fabs(graph1.x - graph2.x) < SMALLNUMBER && fabs(graph1.y - graph2.y) < SMALLNUMBER)
               {
                  // This is when only the two cordinate is give for a circle
                  // .coo x y
                  // .cen x y
                  double radius;
                  double curX = curGraph.x - cur_offset_x;
                  double curY = curGraph.y - cur_offset_y;
                  double x = graph2.x - cur_offset_x;
                  double y = graph2.y - cur_offset_y;

                  CircleCenterPt(curX, curY, x, y, &radius);

                  // Change the last point to first point in circle
                  lastvertex->bulge = 1.0;
                  lastvertex->x = (DbUnit)(curX + radius);
                  lastvertex->y = (DbUnit)(curY);

                  // Add second point to circle
                  Graph_Vertex(curX - radius, curY, 1);
                  // Add third point to close circle
                  Graph_Vertex(curX + radius, curY, 0);

                  // Skip the next set of point in the array
                  i++;
               }
               else
               {
                  double rad;
                  double sa;
                  double da;
                  double x1 = graph1.x - cur_offset_x;
                  double y1 = graph1.y - cur_offset_y;
                  double x2 = graph2.x - cur_offset_x;
                  double y2 = graph2.y - cur_offset_y;
                  double curX = curGraph.x - cur_offset_x;
                  double curY = curGraph.y - cur_offset_y;

                  ArcCenter2(x1, y1, x2, y2, curX, curY, &rad, &sa, &da, grapharray[i].cw);
                  lastvertex->bulge = (DbUnit)tan(da / 4);
               }
            }
            else
            {
               DDEGraph graph2 = grapharray[i+1];
               double rad;
               double curX = curGraph.x - cur_offset_x;
               double curY = curGraph.y - cur_offset_y;
               double x2 = graph2.x - cur_offset_x;
               double y2 = graph2.y - cur_offset_y;
               CircleCenterPt(curX, curY, x2, y2, &rad );

               // Add first point to circle
               Graph_Vertex(curX + rad, curY, 1);
               // Add second point to circle
               Graph_Vertex(curX - rad, curY, 1);
               // Add third point to close circle
               Graph_Vertex(curX + rad, curY, 0);

               // Skip the next set of point in the array
               i++;
            }
         }
         break;

      default:
         fprintf(ferr, "Graphtype [%d] not implemented at %ld.\n", curGraph.typ, linecnt);
         display_error;
         break;
      }

      newpoly = FALSE;
      if (curGraph.borderpart)   
      {
         newpoly = TRUE;
      }
   }

   graphcnt = 0;
   return 1;
}

/******************************************************************************
* write_padgraph
   this writes padshape graphic as standard apertures or complex 
*/
static int write_padgraph(const char *apname)
{
   if (graphcnt == 0)
      return 1;

   CPolyList polyList;
   BOOL newPoly = TRUE;
   CPnt *lastVertex = NULL;
   CPoly *poly = NULL;

   // write into a poly buffer and than later decide if this is an aperture or complex
	int i=0;
   for (i=0; i<graphcnt; i++)
   {

      if (newPoly)
      {
         poly = new CPoly;
         polyList.AddTail(poly);
         poly->setClosed(true);
         poly->setVoid(false);
      }

      DDEGraph curGraph = grapharray[i];
      switch (curGraph.typ)
      {
      case GRAPH_CIR:
         {
            CPnt *pnt = new CPnt;
            pnt->bulge = 1.0;
            pnt->x = (DbUnit)(-curGraph.x - cur_offset_x);
            pnt->y = (DbUnit)(-cur_offset_y);
            poly->getPntList().AddTail(pnt);

            pnt = new CPnt;
            pnt->bulge = 1.0;
            pnt->x = (DbUnit)(curGraph.x - cur_offset_x);
            pnt->y = (DbUnit)(-cur_offset_y);
            poly->getPntList().AddTail(pnt);

            pnt = new CPnt;
            pnt->bulge = 0.0;
            pnt->x = (DbUnit)(-curGraph.x  -cur_offset_x);
            pnt->y = (DbUnit)(-cur_offset_y);
            poly->getPntList().AddTail(pnt);
         }
         break;

      case GRAPH_COO:
         {
            CPnt *pnt = new CPnt;
            pnt->bulge = 0.0;
            pnt->x = (DbUnit)(curGraph.x - cur_offset_x);
            pnt->y = (DbUnit)(curGraph.y - cur_offset_y);
            poly->getPntList().AddTail(pnt);
            lastVertex = pnt;
         }
         break;

      case GRAPH_CEN:
         {
            if (lastVertex && !newPoly)
            {
               DDEGraph graph1 = grapharray[i-1];
               DDEGraph graph2 = grapharray[i+1];
               if (fabs(graph1.x - graph2.x) < SMALLNUMBER && fabs(graph1.y - graph2.y) < SMALLNUMBER)
               {
                  // This is when only the two cordinate is give for a circle
                  // .coo x y
                  // .cen x y
                  double radius;
                  double curX = curGraph.x - cur_offset_x;
                  double curY = curGraph.y - cur_offset_y;
                  double x = graph2.x - cur_offset_x;
                  double y = graph2.y - cur_offset_y;

                  CircleCenterPt(curX, curY, x, y, &radius);

                  // Change the last point to first point in circle
                  lastVertex->bulge = 1.0;
                  lastVertex->x = (DbUnit)(curX + radius);
                  lastVertex->y = (DbUnit)(curY);

                  // Add second point to circle
                  CPnt *pnt = new CPnt;
                  pnt->bulge = 1.0;
                  pnt->x = (DbUnit)(curX - radius);
                  pnt->y = (DbUnit)(curY);
                  poly->getPntList().AddTail(pnt);

                  // Add third point to close circle
                  pnt = new CPnt;
                  pnt->bulge = 0;
                  pnt->x = (DbUnit)(curX + radius);
                  pnt->y = (DbUnit)(curY);
                  poly->getPntList().AddTail(pnt);

                  // Skip the next set of point in the array
                  i++;

                  poly->setVoid(curGraph.cw);
               }
               else
               {
                  double x1 = graph1.x - cur_offset_x;
                  double y1 = graph1.y - cur_offset_y;
                  double x2 = graph2.x - cur_offset_x;
                  double y2 = graph2.y - cur_offset_y;
                  double curX = curGraph.x - cur_offset_x;
                  double curY = curGraph.y - cur_offset_y;

                  double rad;
                  double sa;
                  double da;
                  ArcCenter2(x1, y1, x2, y2, curX, curY, &rad, &sa, &da, curGraph.cw);
                  lastVertex->bulge = (DbUnit)tan(da / 4);
               }
            }
            else
            {
               double rad;
               double curX = curGraph.x - cur_offset_x;
               double curY = curGraph.y - cur_offset_y;
               double x = grapharray[i+1].x - cur_offset_x;
               double y = grapharray[i+1].y - cur_offset_y;

               CircleCenterPt(curX, curY, x, y, &rad );
            
               // Add first point to circle
               CPnt *pnt = new CPnt;
               pnt->bulge = 1.0;
               pnt->x = (DbUnit)(curX + rad);
               pnt->y = (DbUnit)(curY);
               poly->getPntList().AddTail(pnt);

               // Add second point to circle
               pnt = new CPnt;
               pnt->bulge = 1.0;
               pnt->x = (DbUnit)(curX - rad);
               pnt->y = (DbUnit)(curY);
               poly->getPntList().AddTail(pnt);

               // Add third point to close circle
               pnt = new CPnt;
               pnt->bulge = 0;
               pnt->x = (DbUnit)(curX + rad);
               pnt->y = (DbUnit)(curY);
               poly->getPntList().AddTail(pnt);

               // Skip the next set of point in the array
               i++;

               poly->setVoid(curGraph.cw);
            }
         }
         break;

      default:
         fprintf(ferr, "Graphtype [%d] not implemented at %ld.\n", grapharray[i].typ, linecnt);
         display_error;
         break;
      }
   
      if (curGraph.borderpart)
         newPoly = TRUE;
      else
         newPoly = FALSE;
   }

   // update the padshape array
   for (i=0; i<padshapecnt; i++)
   {
      DDEPadshape *padShape = padshapearray[i];
      if (!STRCMPI(padShape->name, apname))
      {
         // to indicate that the padshape is create correctly
         padShape->isGood = TRUE;
         break;
      }
   }

   Graph_Polygon(apname, &polyList);

   graphcnt = 0;
   return 1;
}

/******************************************************************************
* Graph_Polygon
*/
void Graph_Polygon(CString polygonName, CPolyList *polyList)
{
   int err = 0;
   double radius = 0.0;
   double sizeA = 0.0;
   double sizeB = 0.0;
   double centerX = 0.0;
   double centerY = 0.0;
   double lowerLeftX = 0.0;
   double lowerLeftY = 0.0;
   double upperRightX = 0.0;
   double upperRightY = 0.0;

   if (polyList->GetCount() == 1)
   {
      CPoly *poly = polyList->removeHead();

      if (PolyIsCircle(poly, &centerX, &centerY, &radius))
      {
         Graph_Aperture(polygonName, T_ROUND, radius * 2, 0.0, centerX, centerY, 0.0, 0, BL_APERTURE, TRUE, &err);
      }
      else if (PolyIsRectangle(poly, &lowerLeftX, &lowerLeftY, &upperRightX, &upperRightY))
      {
         sizeA = upperRightX - lowerLeftX;
         sizeB = upperRightY - lowerLeftY;
         centerX = lowerLeftX + sizeA / 2;
         centerY = lowerLeftY + sizeB / 2;

         if (sizeA == sizeB)
            Graph_Aperture(polygonName, T_SQUARE, sizeA, 0.0, centerX, centerY, 0.0, 0, BL_APERTURE, TRUE, &err);
         else
            Graph_Aperture(polygonName, T_RECTANGLE, sizeA, sizeB, centerX, centerY, 0.0, 0, BL_APERTURE, TRUE, &err);
      }
      else if (PolyIsOblong(poly, &sizeA, &sizeB, &centerX, &centerY))
      {
         if (sizeA == sizeB)
            Graph_Aperture(polygonName, T_ROUND, sizeA, 0.0, centerX, centerY, 0.0, 0, BL_APERTURE, TRUE, &err);
         else 
            // It seems like in DDE V8, oblong apertures are created the way they are and shouldn't rotate at all
            // regardless if sizeA > sizeB
            Graph_Aperture(polygonName, T_OBLONG, sizeA, sizeB, centerX, centerY, 0.0, 0, BL_APERTURE, TRUE, &err);
      }
      else
      {
         CString complexName = polygonName + "_COMPLEX";
         int layerIndex = Graph_Level("0", 0, 1);
         int widthIndex = Graph_Aperture("", T_ROUND, 0.0, 0.0, 0.0, 0.0, 0.0, 0, BL_WIDTH, 0, &err);

         BlockStruct *block = Graph_Block_On(GBO_APPEND, complexName, -1, 0);
         DataStruct *data = Graph_PolyStruct(layerIndex, 0L, FALSE);
         Graph_Poly(data, widthIndex, poly->isClosed(), poly->isVoid(), poly->isClosed());

         POSITION pntPos = poly->getPntList().GetHeadPosition();
         while (pntPos)
         {
            CPnt * pnt = poly->getPntList().GetNext(pntPos);
            Graph_Vertex(pnt->x, pnt->y, pnt->bulge);
         }
         Graph_Block_Off();
         Graph_Complex(polygonName, 0, complexName, 0.0, 0.0, 0.0);
      }

      delete poly;
   }
   else
   {
      CString complexName = polygonName + "_COMPLEX";
      int layerIndex = Graph_Level("0", 0, 1);
      int widthIndex = Graph_Aperture("", T_ROUND, 0.0, 0.0, 0.0, 0.0, 0.0, 0, BL_WIDTH, 0, &err);

      BlockStruct *block = Graph_Block_On(GBO_APPEND, complexName, -1, 0);
      DataStruct *data = Graph_PolyStruct(layerIndex, 0L, FALSE);

      POSITION pos = polyList->GetHeadPosition();
      while(polyList->GetCount() > 0)
      {
         CPoly *poly = polyList->removeHead();

         if (poly == NULL)
            continue;

         Graph_Poly(data, widthIndex, poly->isClosed(), poly->isVoid(), poly->isClosed());

         POSITION pntPos = poly->getPntList().GetHeadPosition();
         while (pntPos)
         {
            CPnt * pnt = poly->getPntList().GetNext(pntPos);
            Graph_Vertex(pnt->x, pnt->y, pnt->bulge);
         }

         delete poly;
      }

      Graph_Block_Off();
      Graph_Complex(polygonName, 0, complexName, 0.0, 0.0, 0.0);
   }
}

/******************************************************************************
* ipl_cen
*/
static int ipl_cen()
{
   char   *lp;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double x = ipl_unit(atof(lp));

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double y = ipl_unit(atof(lp));

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0; // 0 is cc 1 is clock
   int c = atoi(lp);

   DDEGraph graph;
   graph.x = x;
   graph.y = y;
   graph.cw = c;
   graph.borderpart = 0;
   graph.typ = GRAPH_CEN;
   grapharray.SetAtGrow(graphcnt++, graph);  

   return 1;
}

/******************************************************************************
* ipl_coo
*/
static int ipl_coo()
{
   char   *lp;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double x = ipl_unit(atof(lp));

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double y = ipl_unit(atof(lp));

   DDEGraph graph;
   graph.x = x;
   graph.y = y;
   graph.borderpart = 0;
   graph.typ = GRAPH_COO;
   grapharray.SetAtGrow(graphcnt++, graph);  

   return 1;
}

/******************************************************************************
* ipl_psh
* .psh padshapes : padshapenumber drillsize plated/non filled/non shapename
*/
static int ipl_psh()
{
   char  *lp;
   
   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   int padnr = atoi(lp);

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0; // drill size
   double drill = ipl_unit(atof(lp));

   BOOL plated = FALSE;
   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   if (lp[0] == 'p' || lp[0] == 'P')
      plated = TRUE;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   if ((lp = strtok(NULL, "\n")) == NULL)
      return 0;   // name can have blanks
   cur_name = lp;

   if (!PADSHAPE_PREFIX.IsEmpty())
      cur_name = PADSHAPE_PREFIX + cur_name;

   DDEPadshape *padShape = new DDEPadshape;
   padshapearray.SetAtGrow(padshapecnt++, padShape);
   padShape->name = cur_name;
   padShape->index = padnr;
   padShape->drill = drill;
   padShape->isGood = FALSE;  // initially is FALSE until the shape is creat then it will be set to TRUE
   padShape->plated = plated;

   cur_state = STAT_PADSHAPE;
   graphcnt = 0;

   return 1;
}

/******************************************************************************
* ipl_wlg
* .wlg wlgroup   : status protect/non groupname
*/
static int ipl_wlg()
{
   char  *lp;
   cur_state = STAT_UNKNOWN;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;  // must be n for net
   char flag = lp[0];

   if ((lp = strtok(NULL, "'\n")) == NULL)
      return 0;

   // if not n it is a pin group or other.
   if (flag == 'n' || flag == 'p')  // plane net.
   {
      cur_netname = lp;
      if (!STRNICMP(cur_netname, "NET ", 4))
      {
         CString tmp = cur_name.Right(strlen(cur_netname) - 4);
         cur_netname = tmp;
      }
      cur_netname.MakeUpper();   // all capital
      NetStruct *net = add_net(file, cur_netname);

      cur_state = STAT_NETLIST;
   }

   return 1;
}


/******************************************************************************
* ipl_wlp
* .wlp wlistpin  : compnum x y norm/sing/diff paddir pinnum compname
*                  layer shape   ( 1-255 times )
*
* .wlp 789 129487 941655 n 6 x6 X1_B
*      255 70
*/
static int ipl_wlp()
{
   char *lp;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   int compnr = atoi(lp);
	
   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double x = ipl_unit(atof(lp));

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0; 
   double y = ipl_unit(atof(lp));

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0; 
   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
	int ddeRotationIndex = atoi(lp);
   double padrot = conv_rotation(lp);

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   CString pinname = lp;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   CString compname = lp;

   int padstackNum = -1;
   if ((lp = strtok(NULL, " \t\n")) != NULL)
      padstackNum = atoi(lp);

   compname.TrimLeft();
   compname.TrimRight();
   if (compname.Left(1) == '\'')
      compname.Delete(0, 1);
   if (compname.Right(1) == '\'')
      compname.Delete(strlen(compname) - 1, 1);

   // here check if compname and index is the same
   int cptr = get_compptr(compnr);
   DDEComp *complist = complistarray[cptr];

   if (strlen(complist->name) == 0)
   {
      // here update name. The name may have been on a different layer ...
      complist->name = compname;
   }
   else if (STRCMPI(complist->name, compname))
   {
      // here is a conflict. The compname is different.
      fprintf(ferr, "Component index [%d] and name [%s] in .wlp is different than in .com [%s] at %ld\n",
            compnr, compname, complist->name,linecnt);
      display_error++;
      compname = complist->name;
   }

   for (int i=0; i<MAX_LAYER; i++)
   {
      pinl[i].shapeindex = -1;        // set chape to -1
      pinl[i].done = 0;
   }

   CString padstackName = "PAD";
   while (TRUE)
   {
      int c = fgetc(ifp);
      ungetc(c, ifp);
      if (c == '.')
         break;
      else
      {
         if (fgets(line, MAX_LINE, ifp) == NULL)
         {
            ErrorMessage("Unexpected EOF");
            return -1;
         }

         linecnt++;
         if ((lp = strtok(line, " \t\n")) == NULL)
            continue;
         int layerIndex = atoi(lp);

         if ((lp = strtok(NULL, " \t\n")) == NULL)
            continue;
         pinl[layerIndex].shapeindex = atoi(lp);
         
         CString tmp;
         tmp.Format("_L%d:S%d", layerIndex, pinl[layerIndex].shapeindex);
         padstackName += tmp;
      }
   }

   //if (STRCMPI(compname, "J300") == 0)
   //   int vtr = 1;

   if (GetPadstackName(padstackNum, padstackName, complist->mir) < 0)
      return -1;

   int pinMirror = 0;
   int j=0;
   for (j=0; j<padstackCnt; j++)
   {
      DDEPadstack *padstack = padstackArray[j];
      if ((STRCMPI(padstack->padstackName, padstackName) == 0) && (padstack->stackType == 's'))
      {
         int i=0;
         for (i=0; i<MAX_LAYER; i++)
         {
            if (pinl[i].shapeindex != -1)
            {
               DDELlist *llist = llistarray[i];
               if (((complist->mir) && (llist->comp != 0)) || ((!complist->mir) && (llist->solder != 0)))
               {
                  pinMirror = 1;
               }
            }
         }
      }
   }   

   // needed for.pop attributes.
   mastercomp = compname;
   masterpin = pinname;
   masterdata = NULL;

   if (complist->master)
   {
      char *shapename = get_shapename(complist->shapeindex);
      int sptr = get_shapeptr(complist->shapeindex);
      slistarray[sptr]->pincnt++;

      int prot = round(padrot - complist->rot);
      while (prot < 0)
         prot += 360;
      while (prot >= 360)
         prot -= 360;

      double x1;
      double y1;
      double tmpX = x - complist->x;
      double tmpY = y - complist->y;
      Rotate(tmpX, tmpY, 360.0 - (complist->rot), &x1, &y1);

      if (complist->mir)
		{
         x1 = -x1;
			prot = 360 - prot;
		}

      Graph_Block_On(GBO_APPEND, shapename, -1, 0);
      DataStruct *data = Graph_Block_Reference(padstackName, pinname, 0, x1, y1 ,DegToRad(prot), pinMirror, 1.0,Graph_Level("0", "", 1), TRUE);
      data->getInsert()->setInsertType(insertTypePin);

		// Case 1670
		// If rotation index is >= 4 then mirror the graphics.
		// Mirror the graphics only, not the layers.
		// Also, do not set pinMirror=true prior to Graph_Block_Reference(), as this will cause
		// the insert to be on the bottom as well as mirrored. It should stay on the top.
		// This mirroring is just an image orientation, not a board side designation.
		////if (ddeRotationIndex >= 4)
		////	data->getInsert()->setMirrorFlags(MIRROR_FLIP);
		if (!complist->mir && ddeRotationIndex >= 4)
			data->getInsert()->setMirrorFlags(MIRROR_FLIP);
		else if (complist->mir && ddeRotationIndex < 4)
			data->getInsert()->setMirrorFlags(MIRROR_FLIP);

      masterdata = data;
      Graph_Block_Off();
   }

	CompPinStruct *compPin = NULL;
   if (strlen(cur_netname))
   {
      NetStruct *net = add_net(file, cur_netname);
      compPin = add_comppin(file, net, compname, pinname);
   }
   else
   {
      NetStruct *net = add_net(file, NET_UNUSED_PINS);
      compPin = add_comppin(file, net, compname, pinname);
   }

	if (compPin)
	{
		compPin->setOrigin(x,y);
		compPin->setPinCoordinatesComplete(true);
	}

   return 1;
}

/******************************************************************************
* get_compptr
*/
static int get_compptr(int compnr)
{
   for (int i=0; i<complistcnt; i++)
   {
      if (complistarray[i]->compindex == compnr)
         return i;
   }
   ErrorMessage("Compnr not found");
   return FALSE;
}

/******************************************************************************
* *get_shapename
*/
char *get_shapename(int s)
{
   for (int i=0; i<slistcnt; i++)
   {
      if (slistarray[i]->index == s)
         return slistarray[i]->name.GetBuffer(0);
   }
   fprintf(ferr, "Shape index [%d] not found in Slist at %ld\n", s, linecnt);
   display_error++;

   return NULL;
}

/******************************************************************************
* get_shapeptr
*/
static int get_shapeptr(int shapenr)
{
   for (int i=0; i<slistcnt; i++)
   {
      if (slistarray[i]->index == shapenr)
         return i;
   }
   ErrorMessage("Shapenr not found");
   
   return -1;
}

/******************************************************************************
* get_padshape
*/
static int get_padshape(int code)
{
   for (int i=0; i<padshapecnt; i++)
   {
      // only return the index if the padshape exist and is good which mean it is created
      if (padshapearray[i]->index == code && padshapearray[i]->isGood)
         return i;
   }

   return -1;
}

/******************************************************************************
* ipl_bur
*    .bur buried via: psha,psha,.. x y lay,lay,.. paddirection
*/
static int ipl_bur()
{
   char *lp;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   char pshatok[80];
   strcpy(pshatok, lp);

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double x = ipl_unit(atof(lp));

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double y = ipl_unit(atof(lp));

   // layer array
   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   char laytok[80];
   strcpy(laytok, lp);

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double rot = conv_rotation(lp);

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   int padstackNum = atoi(lp);

   int allLayer = -1;
   if ((lp = strtok(NULL, " \t\n")) != NULL)
      allLayer = atoi(lp);  // optional field, always 255 which indicate all layers

   // here seperate layers
   int layer[MAX_LAYER];
	int i=0;
   for (i=0; i<MAX_LAYER; i++)
       layer[i] = -1;

   int lcnt = 0; 
   lp = strtok(laytok, ",");
   while (lp)
   {
      layer[lcnt] = atoi(lp);
      lcnt++;      
      lp = strtok(NULL, ",");
   }

   // here seperate psha
   for (i=0; i<MAX_LAYER; i++)
       pinl[i].shapeindex = -1;

   int pcnt = 0;
   lp = strtok(pshatok, ",");
   CString padstackName = "PAD";
   while (lp)
   {
      int layerNum = layer[pcnt];
      pinl[layerNum].shapeindex = atoi(lp);
      pcnt++;      
      lp = strtok(NULL, ",");
  
      CString tmp;
      tmp.Format("_L%d:S%d", layerNum, pinl[layerNum].shapeindex);
      padstackName += tmp; 
   }

   // To resolve case dts0100377201, which is to create instance specific padstack for buried via.
   // In order to get the specified padshapes and layer padstack, we don't pass it he padstackNum
   // we let GetstackName() find the padstack by name. If it can't find it, then it will create one.
   if (GetPadstackName(-1, padstackName, FALSE) < 0)
      return -1;

   switch (cur_state)
   {
   case STAT_SHAPE:
/*
      // here pin
      slist[slistcnt-1].pincnt++;
      sprintf(pinname,"$%d",slist[slistcnt-1].pincnt);

      x = x - slist[slistcnt-1].xref;
      y = y - slist[slistcnt-1].yref;

      if ((res = L_Pin(pinname,cur_name,padname,slist[slistcnt-1].pincnt)) != OK)
      {
         printf("Error %d in L_Pin\n",res);
      }
      if ((res = L_PinPos(pinname,cur_name,inch_2_dbunitpoint2(x,y),
               0,degree_2_dbunit(0.0))) != OK)
      {
         printf("Error %d in L_PinPos\n",res);
      };
      SCLG_Shape(cur_name);
*/
      break;
   case STAT_NETLIST:
      {
         // here via
         DataStruct *data = Graph_Block_Reference(padstackName, NULL, -1, x, y, DegToRad(rot), 0, 1.0,Graph_Level("0", "", 1), TRUE);
         data->getInsert()->setInsertType(insertTypeVia);
         if (allLayer == -1)
            doc->SetUnknownAttrib(&data->getAttributesRef(), ATT_BLINDSHAPE, "", SA_OVERWRITE, NULL);
         if (strlen(cur_netname))
            doc->SetUnknownAttrib(&data->getAttributesRef(), ATT_NETNAME, cur_netname, SA_OVERWRITE, NULL);
      }
      break;
   default:
      // unknown status
      fprintf(ferr, "Unknown .pad status at %ld\n", linecnt);
      display_error++;
      break;
   }

   return 1;
}

/******************************************************************************
* ipl_wle
* .wle end wirelist
*/
static int ipl_wle()
{
	cur_name = "";
	cur_netname = "";
   
	cur_state = STAT_UNKNOWN;

   return 1;
}

/******************************************************************************
* ipl_pad
* .pad via       : padshapenum x y layer paddirection
*/
static int ipl_pad()
{
   //char  layer[20];
   char     padname[80];
   char     *lp;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   int padcode = atoi(lp);

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double x = ipl_unit(atof(lp));

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double y = ipl_unit(atof(lp));

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   int laynr = atoi(lp);

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   double rot = conv_rotation(lp);

   sprintf(padname, "PAD_%d_%d_%d", padcode, laynr, rot);
   update_padname(padname, padcode, laynr, round(rot));

   switch (cur_state)
   {
   case STAT_SHAPE:
/*
      // here pin
      slist[slistcnt-1].pincnt++;
      sprintf(pinname,"$%d",slist[slistcnt-1].pincnt);

      x = x - slist[slistcnt-1].xref;
      y = y - slist[slistcnt-1].yref;

      if ((res = L_Pin(pinname,cur_name,padname,slist[slistcnt-1].pincnt)) != OK)
      {
         printf("Error %d in L_Pin\n",res);
      }
      if ((res = L_PinPos(pinname,cur_name,inch_2_dbunitpoint2(x,y),
               0,degree_2_dbunit(0.0))) != OK)
      {
         printf("Error %d in L_PinPos\n",res);
      };
      SCLG_Shape(cur_name);
*/
      fprintf(ferr,".PAD statement insize .typ [%s] ignored at %ld\n", cur_name, linecnt);
      display_error++;
      break;
   case STAT_NETLIST:
      {
         // here via
         DataStruct *data = Graph_Block_Reference(padname, NULL, -1, x, y, DegToRad(rot), 0 , 1.0,Graph_Level("0","",1), TRUE);
         data->getInsert()->setInsertType(insertTypeVia);
         if (strlen(cur_netname))
            doc->SetUnknownAttrib(&data->getAttributesRef(), ATT_NETNAME, cur_netname, SA_OVERWRITE, NULL);
      }
      break;
   case STAT_UNKNOWN:
      {
         // here a free pad
         DataStruct *data = Graph_Block_Reference(padname, NULL, -1, x, y, DegToRad(rot), 0 , 1.0,Graph_Level("0","",1), TRUE);
         data->getInsert()->setInsertType(insertTypeFreePad);
      }
      break;
   default:
      // unknown status
      fprintf(ferr,"Unknown .pad status at %ld\n", linecnt);
      display_error++;
      break;
   }

   return 1;
}

/******************************************************************************
* update_padname
*/
static int update_padname(char *padname,int padcode,int laynr,int rot)
{
   for (int i=0; i<padcnt; i++)
   {
      DDEPad *pad = padarray[i];
      if (pad->padcode == padcode && pad->laynr == laynr && pad->rot == rot)
             return i;
   }

   DDEPad *pad = new DDEPad;
   padarray.SetAtGrow(padcnt++, pad);
   pad->padcode = padcode;
   pad->laynr = laynr;
   pad->rot = rot;

   // here now write graphic
   CString play;
   int padshapeptr = get_padshape(padcode);
   if (padshapeptr < 0)
   {
      fprintf(ferr, "Can not find padshape [code %d]\n", padcode);
      display_error++;
   }
   else
   {
      play.Format("L%d", laynr);
      int lindex = Graph_Level(play, "", 0);
      BlockStruct *block = Graph_Block_On(GBO_APPEND, padname, -1, 0);
      Graph_Block_Reference(padshapearray[padshapeptr]->name, NULL, 0, 0.0, 0.0, 0.0, 0, 1.0, lindex, TRUE);

      double drill = padshapearray[padshapeptr]->drill;
      BOOL plated = padshapearray[padshapeptr]->plated;
      if (drill)  
      {
         int lindex = Graph_Level("DRILLHOLE", "", 0);
         int drillindex = get_drillindex(drill, plated); 
         if (drillindex > -1)
         {
            CString  drillname;
            drillname.Format("DRILL_%d",drillindex);
            Graph_Block_Reference(drillname, NULL, 0, 0.0, 0.0, 0.0, 0, 1.0, lindex, TRUE);
         }
      }

      block->setBlockType(BLOCKTYPE_PADSTACK);
      Graph_Block_Off();
   }

   return padcnt-1;
}

/******************************************************************************
* do_layer
*  Electrical layers must be first in list.
*/
static int do_layer()
{
   int lcnt = 0;
   int compnumber = 0;
   int soldernumber = 0;
	int i=0;
   for (i=0; i<llistcnt; i++)
   {
      DDELlist *llist = llistarray[i];
      if (llist->solder)
		{
         soldernumber ++;
			if (soldernumber == 1)
				lcnt++;
		}
      else if (llist->comp)
		{
         compnumber++;
			if (compnumber == 1)
				lcnt++;
		}
      else if (llist->electrical)
         lcnt++;
   }

   int stackcnt;
   if (compnumber > 0 && soldernumber > 0)
   {
      stackcnt = 1;

      // here assign electrical stackup
      for (i=0; i<llistcnt; i++)
      {
         CString lname;
         lname.Format("L%d", i);
         LayerStruct *layer = doc->FindLayer_by_Name(lname);
         if (layer == NULL)
            continue;

         DDELlist *llist = llistarray[i];
         if (llist->solder)
            layer->setElectricalStackNumber(lcnt);
         else if (llist->comp)
            layer->setElectricalStackNumber(1);
         else if (llist->electrical)
            layer->setElectricalStackNumber(++stackcnt);
      }
   } 

   LayerStruct *layer = doc->FindLayer_by_Name("L255");
   if (layer)
      layer->setLayerType(LAYTYPE_PAD_ALL);

   // layer attribute
   for (i=0; i<layer_attr_cnt; i++)
   {
      int res = get_layerindex_from_name(layer_attr[i].name);
      if (res > -1)
      {
         CString lname;
         lname.Format("L%d", res);

         LayerStruct *layer = doc->FindLayer_by_Name(lname);
         if (!layer)
         {
            lname = layer_attr[i].name;
            layer = doc->FindLayer_by_Name(lname);
         }

         if (layer)
            layer->setLayerType(layer_attr[i].attr);
      }
   }

   for (i=0; i<llistcnt; i++)
   {
      if (llistarray[i]->mirrorindex != i)
      {
         CString layerName1;
         CString layerName2;
         layerName1.Format("L%d", i);
         layerName2.Format("L%d", llistarray[i]->mirrorindex);

         Graph_Level(layerName1, "", 0);     
         Graph_Level(layerName2, "", 0);
         Graph_Level_Mirror(layerName1, layerName2 , "");

         LayerStruct *layer1 = doc->FindLayer_by_Name(layerName1);
         if (layer1 == NULL)
            continue;

         LayerStruct *layer2 = doc->FindLayer_by_Name(layerName2);
         if (layer2 == NULL)
            continue;

         if (layer1->getLayerType() == LAYTYPE_PASTE_TOP)
            layer2->setLayerType(LAYTYPE_PASTE_BOTTOM);
         if (layer1->getLayerType() == LAYTYPE_PASTE_BOTTOM)
            layer2->setLayerType(LAYTYPE_PASTE_TOP);

         if (layer1->getLayerType() == LAYTYPE_MASK_TOP)
            layer2->setLayerType(LAYTYPE_MASK_BOTTOM);
         if (layer1->getLayerType() == LAYTYPE_MASK_BOTTOM)
            layer2->setLayerType(LAYTYPE_MASK_TOP);

         if (layer1->getLayerType() == LAYTYPE_SILK_TOP)
            layer2->setLayerType(LAYTYPE_SILK_BOTTOM);
         if (layer1->getLayerType() == LAYTYPE_SILK_BOTTOM)
            layer2->setLayerType(LAYTYPE_SILK_TOP);

         if (layer1->getLayerType() == LAYTYPE_TOP)
            layer2->setLayerType(LAYTYPE_BOTTOM);
         if (layer1->getLayerType() == LAYTYPE_BOTTOM)
            layer2->setLayerType(LAYTYPE_TOP);
      }
   }
   
   return 1;
}

/******************************************************************************
* ipl_mir
* .mir mirrormap : fromlay tolay
*/
static int ipl_mir()
{  
   char *lp;
 
   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   int index1 = atoi(lp);

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   int index2 = atoi(lp);

   if (index1 < 0 || index1 >= llistcnt)
              return 0;
   if (index2 < 0 || index2 >= llistcnt)
              return 0;

   llistarray[index1]->mirrorindex = index2;
   llistarray[index2]->mirrorindex = index1;

   return 1;
}

/******************************************************************************
* get_layerindex_from_name
*/
int get_layerindex_from_name(const char *l)
{
   for (int i=0; i< llistcnt; i++)
   {
      if (!STRCMPI(llistarray[i]->name,l))
           return i;
   }
   return -1;
}

/******************************************************************************
* ipl_lpm
*/
static int ipl_lpm()
{
   char *lp;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   if (lp[0] == '\'')
   {
      if ((lp = strtok(NULL, "'")) == NULL)
         return 0;
   }     
   CString lname = lp;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   CString lsys = lp;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   CString lpoly = lp;

   DDELpm *lpm = new DDELpm;
   lpmarray.SetAtGrow(lpmcnt++, lpm);
   lpm->name = lname;
   lpm->sys = lsys;
   lpm->poly = lpoly;
   
   lpoly.Trim();
   lpoly.MakeLower();
   if (lpoly == "ps")
      lpm->isBottomLayer = TRUE;
   else
      lpm->isBottomLayer = FALSE;

   return 1;
}

/******************************************************************************
* get_height
*/
static double get_height(const char *val)
{
   // mil = mil
   // M = 100 mils
   // mm = millimeters
   // um = micrometers
   // in = inch
   // cm = centimeter
   double height = atof(val);
   char tmp[255];
   strcpy(tmp, val);

   char *v = tmp;
   while (*v && !isalpha(*v))
      v++;

   if (strlen(val))
   {
      if (!STRNICMP(v, "MM", 2))
         height *= Units_Factor(UNIT_MM, pageunits);  
      else if (!STRNICMP(v, "UM", 2))
         height *= Units_Factor(UNIT_MM, pageunits) * 1000; 
      else if (!STRNICMP(v, "CM", 2))
         height *= Units_Factor(UNIT_MM, pageunits) / 10;   
      else if (!STRNICMP(v, "MI", 2))
         height *= Units_Factor(UNIT_MILS, pageunits);   
      else if (!STRNICMP(v, "IN", 2))
         height *= Units_Factor(UNIT_INCHES, pageunits); 
      else if (!strcmp(v, "M"))
         height *= Units_Factor(UNIT_MILS, pageunits) / 100;   
   }

   return height;
}

/******************************************************************************
* ipl_cop
*/
static int ipl_cop()
{
   char     *lp;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   CString origkey = lp;
   CString key = get_attribmap(lp);

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   CString val = lp;
   if (val[0] == '\'')
   {
      if ((lp = strtok(NULL, "'\n")) != NULL)
         val += (CString)" " + lp;
      val.TrimLeft();
      val.TrimRight();
      if (val.Left(1) == '\'')
         val.Delete(0,1);
      if (val.Right(1) == '\'')
         val.Delete(strlen(val) - 1, 1);
   }

   switch (cur_state)
   {
   case STAT_SHAPE:
      {
         if (!origkey.CompareNoCase("kind"))
         {
            slistarray[slistcnt-1]->kind = val;
         }
         else if (!STRCMPI(key, ATT_COMPHEIGHT) || !STRCMPI(key, "pcb_thickness"))
         {
            double height = get_height(val);
            if (height > 0)
            {
               BlockStruct *block = Graph_Block_On(GBO_APPEND, cur_name, -1, 0);
               doc->SetAttrib(&block->getAttributesRef(),doc->IsKeyWord(ATT_COMPHEIGHT, 0), VT_UNIT_DOUBLE, 
                     (double *)&height, SA_OVERWRITE, NULL);
               Graph_Block_Off();
            }
         }
         else
         {
            BlockStruct *block = Graph_Block_On(GBO_APPEND, cur_name, -1, 0);
            doc->SetUnknownAttrib(&block->getAttributesRef(), key, val, SA_OVERWRITE, NULL);
            Graph_Block_Off();
         }
      }
      break;
   case STAT_COMPONENT:
      {
         CString cname;
         cname.Format("%d", complistarray[complistcnt-1]->compindex);
         DataStruct *data = datastruct_from_refdes(doc, file->getBlock(), cname);
         if (data)
         {
            if (!origkey.CompareNoCase("kind"))
            {
               if (!STRNICMP(val, "Fid", 3))
               {
                  complistarray[complistcnt-1]->fiducial = true;
                  break;
               }
               if (!STRNICMP(val, "Test", 4))
               {
                  complistarray[complistcnt-1]->testpoint = true;
                  break;
               }
               if (!STRNICMP(val, "Board", 5))
               {
                  complistarray[complistcnt-1]->boardoutline = true;
                  int ptr = get_slistptr(complistarray[complistcnt-1]->shapeindex);
                  if (ptr > -1)
                     slistarray[ptr]->kind = val;
                  break;
               }
            }
            
            if (!STRCMPI(key, "height") || !STRCMPI(key, "pcb_thickness"))
            {
               double height = get_height(val);
               if (height > 0)
               {
                  doc->SetAttrib(&data->getAttributesRef(), doc->IsKeyWord(ATT_COMPHEIGHT, 0),
                        VT_UNIT_DOUBLE, (double *)&height, SA_OVERWRITE, NULL);
               }
            }
            else
            {
               doc->SetUnknownAttrib(&data->getAttributesRef(), key, val, SA_OVERWRITE, NULL); 
            }
         } // if d
      }
      break;
   }
   return 1;
}

/******************************************************************************
* ipl_pop
*/
static int ipl_pop()
{
   char *lp;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   CString key = get_attribmap(lp);

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   CString val = lp;

   if (strlen(mastercomp) && strlen(masterpin))
   {
      // here check if compname and index is the same
      if (masterdata)
      {
         if (!key.CompareNoCase("pinusage") && !val.CompareNoCase("fiducial"))
         {
            masterdata->getInsert()->setInsertType(insertTypeFiducial);
            // delete pins from netlist - fiducials are not pins.
            RemoveCompPin(file, mastercomp, masterpin);
         }
         else
         {
            doc->SetUnknownAttrib(&masterdata->getAttributesRef(), key, val, SA_OVERWRITE, NULL); //  
         }
      }
   }

   switch (cur_state)
   {
   case STAT_NETLIST:
      break;
   default:
      fprintf(ferr, "Unknown .pop status at %ld\n", linecnt);
      display_error++;
      break;
   }

   return 1;
}

/******************************************************************************
* ipl_blo
*/
static int ipl_blo()
{
   return 1;
}

/******************************************************************************
* ipl_wop
*  .wop plane 3
*/
static int ipl_wop()
{
   char  *lp;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   CString option = lp;

   if ((lp = strtok(NULL, " \t\n")) == NULL)
      return 0;
   CString val = lp;

   if (!option.CompareNoCase("plane"))
   {
      // here do powerplane on net and layer
      CString layername;
      layername.Format("L%d", atoi(val));

      LayerStruct *layer = doc->FindLayer_by_Name(layername);
      if (layer )
         doc->SetUnknownAttrib(&layer->getAttributesRef(), LAYATT_NETNAME, cur_netname, SA_APPEND, NULL); 

      NetStruct *net = add_net(file, cur_netname);
      if (net)
         doc->SetUnknownAttrib(&net->getAttributesRef(), ATT_POWERNET, "", SA_OVERWRITE, NULL); 
   }

   return 1;
}
